<!doctype html>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0'>
<title>Block</title>
<style>
* {box-sizing:border-box;}
:root {
	--bg:#000;
	--size:6vh;
	accent-color:#404040;
	color-scheme:dark;
}
body, html, main {height:100%;}
body, button, input {
	font-family:'Roboto Mono','Noto Mono',monospace,system-ui;
	font-size:clamp(10px,2vw,16px);
	line-height:1.5;
}
body {
	background:var(--bg);
	border-left: transparent 2px solid;
	display:flex;
	flex-direction:column;
	flex:1;
	margin:0;
	overflow:hidden;
}
body:focus {border-color:rgb(60,0,60);}
button, label, input {
	cursor:pointer;
	touch-action:manipulation;
	user-select:none;
}
input[type=checkbox]{height:1em;width:1em;}
button, .button {
	background:0;
	border-color:rgba(127,127,127,.5);
	border-width:1px;
}
hr {border-width:0 1px 0 0;}
input {background:0;border:0;border-radius:0;padding:0;}
input:focus{outline:1px solid;}
.button {border-style:outset;}
.column {display:flex;flex-direction:column;}
.ctrl {
	align-self: flex-end;
	fill:#FFF;
	height:var(--size);
	padding:0;
	user-select:none;
	width:var(--size);
}
.fade {opacity:.5;}
.grow {flex-grow:1;}
.hotkey {text-decoration:underline dotted;}
.row {display:flex;}
.text-btn {
	padding:2px 2px 2px 0;
	text-align: right;
}
.uni-btn {line-height:0;}
.wide {width:100%;}
input[type=checkbox]{margin:0 0 0 2px;}
input[type=number]{direction:rtl;}
#status {white-space-collapse:preserve;}
</style>
<body autofocus tabindex='0'>
<main class='row'>
<svg class='grow' viewBox='0 0 10 23'>
	<rect id='wall' fill='transparent' width='10' height='23'></rect>
</svg>
<div class='column' style='min-width:7ch;width:var(--size);'>
<div id='status' class='text-btn'></div>
<div class='fade grow column'>
<label class='button text-btn'>
	<span class='hotkey'>G</span>rav<input id='grav' onChange='document.body.focus();game.gravitate(void 0, this.checked, true)' type='checkbox' autocomplete='off'>
</label>
<label class='button text-btn row'>
	<input id='bpf' class='grow' min='0' max='20' step='1' onChange='game.gravitate(void 0, void 0, true, parseInt(this.value))' type='number' autocomplete='off'
	>G
</label>
<label class='button text-btn'>
	Delay<br>
	<input id='delay' class='wide' min='0' step='.1' onChange='game.gravitate(1000 * parseFloat(this.value), void 0, true)' type='number' autocomplete='off'>
</label>
<button title='Reset' onClick='document.body.focus();game.reset()' class='ctrl'>
	<svg viewBox="0 0 128 128">
		<path d="M108.46,63.96v-25.7c0-1.8-1.7-2.9-3-2l-35,24.4v-22.4c0.13-1.13-0.69-2.15-1.82-2.28
		c-0.45-0.05-0.9,0.05-1.28,0.28l-36.9,25.1v-23.5c0-1.05-0.85-1.9-1.9-1.9h0h-10.2c-1.05,0-1.9,0.85-1.9,1.9l0,0v52.3
		c0,1.05,0.85,1.9,1.9,1.9h0h10.3c1.05,0,1.9-0.85,1.9-1.9l0,0v-23.6l36.9,25c0.98,0.58,2.24,0.26,2.82-0.72
		c0.23-0.39,0.33-0.84,0.28-1.28v-22.3l35,24.4c1.4,0.9,3-0.2,3-2L108.46,63.96z"/>
	</svg>
</button>
<button title='Controls' class='ctrl' onClick="document.querySelectorAll('.touch').forEach(el=>el.hidden=!el.hidden);let t=eid('touch');t.checked=!t.checked;t.checked||document.body.focus();">
	&vellip;
	<input id='touch' checked hidden type='checkbox'>
</button>
<hr class='fade grow'>
<button onPointerDown="game.input('left')" class='ctrl touch' aria-label='Left'>
	<svg viewBox="0 0 128 128">
		<path d="M83.72,62.21v-25.7c0.03-1.25-0.96-2.28-2.21-2.31c-0.42-0.01-0.83,0.1-1.19,0.31l-43.5,25.7c-1.13,0.72-1.47,2.22-0.75,3.35c0.19,0.3,0.45,0.55,0.75,0.75l43.5,25.6c1.08,0.63,2.46,0.27,3.09-0.81c0.21-0.36,0.32-0.77,0.31-1.19V62.21z"/>
	</svg>
</button>
<button onPointerDown="game.input('right')" class='ctrl touch' aria-label='Right'>
	<svg viewBox="0 0 128 128">
		<path d="M43.7,62.21v-25.7c-0.03-1.25,0.96-2.28,2.21-2.31c0.42-0.01,0.83,0.1,1.19,0.31l43.5,25.7c1.13,0.72,1.47,2.22,0.75,3.35c-0.19,0.3-0.45,0.55-0.75,0.75l-43.5,25.6c-1.08,0.63-2.46,0.27-3.09-0.81c-0.21-0.36-0.32-0.77-0.31-1.19V62.21z"/>
	</svg>
</button>
<button onPointerDown="game.input('reverse')" class='ctrl touch' aria-label='Reverse'>
	<div class='uni-btn' style='font-size:var(--size);'>&#x21b6;</div>
</button>
<button onPointerDown="game.input('rotate')" class='ctrl touch' aria-label='Rotate'>
	<div class='uni-btn' style='font-size:var(--size);'>&#x21b7;</div>
</button>
<button onPointerDown="game.input('hold')" class='ctrl touch' aria-label='Hold'>
	<svg viewBox="-16 -16 160 160">
		<path d="M27.3,36.56c0,0,19.47,10.45,20.59,10.95c1.12,0.51,2.64-0.2,3.35-1.83c0.71-1.62,11.16-21.1,11.66-21.91s0.91-2.33,2.74-1.52s4.16-5.27,4.16-5.27L51.13,6.03L41.9,7.25L26.59,34.94L27.3,36.56z"/>
		<path d="M26.38,84.33c0,0,27.18,0.3,28.81,0.3c1.62,0,3.14,0.41,3.35,2.54c0.2,2.13-0.2,26.37-0.2,26.37l-10.45,0.1l-15.52-0.71l-8.32-3.45l-6.49-15.11L26.38,84.33z"/>
		<path d="M107.73,43.86c0,0-21.2,12.48-21.71,12.78s-1.12,1.32-0.2,2.94s11.06,20.08,11.87,21.5c0.81,1.42,1.72,3.14,0.3,4.16c-1.42,1.01,2.13,4.67,2.13,4.67l10.04-1.12l6.8-4.36l5.07-8.42c0,0-0.91-9.94-1.12-10.24c-0.2-0.3-9.43-18.97-9.43-18.97L107.73,43.86z"/>
		<path d="M75.45,37.56c0,0-10.57-16.32-13.97-20.17c-2.67-3.03-5.55-5.51-8.07-7.56c-2.28-1.85-3.95-2.19-5.93-1.88c-3.12,0.49-4.94,1.99-6.69,4.97C35.52,21.87,27.3,36.56,27.3,36.56s-2.89-0.91-2.94-2.84C24.3,31.88,36.12,11.81,37.34,9.68c1.22-2.13,3.25-4.87,8.82-5.17S80.95,4,82.57,4.31s5.38,1.83,8.82,7.1c3.94,6.03,6.45,11.38,6.45,11.38s7.75-4.59,8.56-4.08c1.22,0.76-10.81,24.33-11.77,25.15c-0.6,0.52-27.69,2.23-28.3,0.71C65.94,43.56,75.45,37.56,75.45,37.56z"/>
		<path d="M107.73,43.86c0,0,1.43-1.27,2.57-0.92c1.14,0.36,11.67,22.88,12.72,25.08c1.06,2.2,1.67,7.48-1.58,12.76c-3.26,5.28-18.92,28.87-20.07,30.28c-1.14,1.41-1.76,2.64-4.93,2.64c-3.17,0-15.14-0.18-15.14-0.18s-0.44,8.89-0.53,9.68s-1.41,1.32-2.29-0.26s-13.38-22.71-13.38-23.24c0-0.53,12.23-24.71,14-24.47c1.27,0.18,1.14,9.77,1.14,9.77s27.55-0.53,30.28-0.7c2.73-0.18,5.37-1.23,6.78-3.34s4.58-7.13,2.2-12.32c-2.12-4.62-9.42-18.92-10.47-21.04C108.36,46.27,107.39,44.87,107.73,43.86z"/>
		<path d="M58.33,113.54c-0.39,1.53-1.59,1.57-3,1.66c-1.41,0.09-20.42,0-24.56-0.44c-4.14-0.44-8.1-3.52-9.59-6.95c-1.5-3.43-7.57-14.17-11.79-23.06S4.2,73.31,3.93,71.28s2.02-7.13,4.31-10.83c2.29-3.7,3.87-5.99,3.87-5.99s-8.29-5.46-8.45-6.51c-0.11-0.7,8.35-0.95,15.58-1.23c7.12-0.28,14.35-0.44,14.88,0.09c0.53,0.53,4.31,8.36,6.51,12.85s6.69,12.76,6.6,13.55c-0.13,1.14-1.29,0.57-2.96-0.14c-1.67-0.7-7.86-3.91-7.86-3.91s-6.95,11.88-9.68,17.43c-2.73,5.55-5.37,10.91-4.67,15.84c0.43,2.98,4.05,8.27,10.74,8.98s21.56,0.26,23.33,0.35C57.89,111.86,58.69,112.15,58.33,113.54z"/>
	</svg>
</button>
<button id='up' onPointerDown="game.input('up')" class='ctrl touch' aria-label='Up'>
	<svg viewBox="0 0 128 128">
		<path d="M64,92h29.2c1.48-0.02,2.67-1.23,2.65-2.71c-0.01-0.45-0.12-0.89-0.35-1.29L66.3,37.3c-0.7-1.27-2.31-1.73-3.58-1.02c-0.43,0.24-0.79,0.59-1.02,1.02L32.5,88c-0.73,1.29-0.28,2.92,1.01,3.65c0.39,0.22,0.84,0.34,1.29,0.35H64z"/>
	</svg>
</button>
<button onPointerDown="game.input('down')" class='ctrl touch' aria-label='Down'>
	<svg viewBox="0 0 128 128">
		<path d="M64.2,39.7H34.8c-1.48,0.02-2.67,1.23-2.65,2.71c0.01,0.45,0.12,0.89,0.35,1.29l29.3,51c0.7,1.27,2.31,1.73,3.58,1.02c0.43-0.24,0.79-0.59,1.02-1.02l29.3-51c0.73-1.29,0.28-2.92-1.01-3.65c-0.39-0.22-0.84-0.34-1.29-0.35L64.2,39.7z"/>
	</svg>
</button>
<button onPointerDown="game.input('drop')" class='ctrl touch' aria-label='Drop'>
	<svg viewBox="0 0 128 128">
		<path d="M67.76,61.95h22.3c1.13-0.13,2.15,0.69,2.28,1.82c0.05,0.45-0.05,0.9-0.28,1.28l-25.6,39.9c-0.76,1.1-2.28,1.38-3.38,0.62c-0.24-0.17-0.45-0.38-0.62-0.62l-25.7-39.9c-0.58-0.98-0.26-2.24,0.72-2.82c0.39-0.23,0.84-0.33,1.28-0.28h22.3l-24.4-37c-0.9-1.4,0.2-3,2-3h51.5c1.8,0,2.9,1.7,2,3L67.76,61.95z"/>
	</svg>
</button>
</div></div></main>
<script>
const eid = document.getElementById.bind(document)
const appid = 'dsblock'
const color_margin = [30,0,30]
document.documentElement.style.setProperty('--bg', `rgb(${color_margin.join()})`)
const {ceil,floor,max,min,random,round} = Math
const N = 4
const NN = N * N
class Block{
	static prev_z = .333
	static score = {
		1: 100,
		2: 300,
		3: 500,
		4: 800,
	}
	static kick = {
		'I01':[[0,0],[-2,0],[ 1, 0],[-2, 1],[ 1,-2]],
		'I03':[[0,0],[-1,0],[ 2, 0],[-1,-2],[ 2, 1]],
		'I10':[[0,0],[ 2,0],[-1, 0],[ 2,-1],[-1, 2]],
		'I12':[[0,0],[-1,0],[ 2, 0],[-1,-2],[ 2, 1]],
		'I21':[[0,0],[ 1,0],[-2, 0],[ 1, 2],[-2,-1]],
		'I23':[[0,0],[ 2,0],[-1, 0],[ 2,-1],[-1, 2]],
		'I30':[[0,0],[ 1,0],[-2, 0],[ 1, 2],[-2,-1]],
		'I32':[[0,0],[-2,0],[ 1, 0],[-2, 1],[ 1,-2]],
		'J01':[[0,0],[-1,0],[-1,-1],[ 0, 2],[-1, 2]],
		'J03':[[0,0],[ 1,0],[ 1,-1],[ 0, 2],[ 1, 2]],
		'J10':[[0,0],[ 1,0],[ 1, 1],[ 0,-2],[ 1,-2]],
		'J12':[[0,0],[ 1,0],[ 1, 1],[ 0,-2],[ 1,-2]],
		'J21':[[0,0],[-1,0],[-1,-1],[ 0, 2],[-1, 2]],
		'J23':[[0,0],[ 1,0],[ 1,-1],[ 0, 2],[ 1, 2]],
		'J30':[[0,0],[-1,0],[-1, 1],[ 0,-2],[-1,-2]],
		'J32':[[0,0],[-1,0],[-1, 1],[ 0,-2],[-1,-2]],
	}
	static pb = {
		I: [0b00011110000, 0b100010001000100, 0b111100000000, 0b10001000100010],
		J: [0b00001110001, 0b000001000100110, 0b010001110000, 0b00001100100010],
		L: [0b00001110100, 0b000011000100010, 0b000101110000, 0b00001000100011],
		O: [0b11001100000, 0b000011001100000, 0b011001100000, 0b00011001100000],
		S: [0b00000110110, 0b000010001100010, 0b001101100000, 0b00001000110001],
		T: [0b00001110010, 0b000001001100010, 0b001001110000, 0b00001000110010],
		Z: [0b00001100011, 0b000001001100100, 0b011000110000, 0b00000100110010],
	}
	static padb = {I:2,J:2,L:2,O:1,S:2,T:2,Z:2}
	static padl = {I:0,J:0,L:0,O:1,S:0,T:0,Z:0}
	static padr = {I:0,J:1,L:1,O:1,S:1,T:1,Z:1}
	static padt = {I:1,J:0,L:0,O:1,S:0,T:0,Z:0}
	static y_init = -1
	static y_min = {
		I: [-1, -4, -1, -4],
		J: [-2, -3, -2, -3],
		L: [-2, -3, -2, -3],
		O: [-2, -2, -2, -2],
		S: [-2, -3, -2, -3],
		T: [-2, -3, -2, -3],
		Z: [-2, -3, -2, -3],
	}
	static ci = {I:1,J:2,L:3,O:4,S:5,T:6,Z:7}
	static pieces = Object.keys(Block.pb)
	static color_default = {
		bg: [0,0,0],
		I: [150,0,255],
		J: [0,125,250],
		L: [255,215,0],
		O: [255,140,0],
		S: [0,240,0],
		T: [64,224,208],
		Z: [192,0,0],
		1: [225,125,255],
		2: [125,175,250],
		3: [255,215,107],
		4: [255,140,70],
		5: [72,216,72],
		6: [64,224,208],
		7: [192,96,96],
		8: [80,40,80],
	}
	static keymap = {
		'ArrowDown': 'down',
		'ArrowLeft': 'left',
		'ArrowRight': 'right',
		'ArrowUp': 'up',
		'Backspace': 'pause',
		'BracketLeft': 'delay_decrement',
		'BracketRight': 'delay_increment',
		'Comma': 'bpf_decrement',
		'Delete': 'reverse',
		'End': 'drop',
		'Enter': 'drop',
		'Equal': 'bpf_increment',
		'Escape': 'pause',
		'F2': 'reset',
		'Home': 'hold',
		'KeyA': 'left',
		'KeyC': 'rotate',
		'KeyD': 'right',
		'KeyE': 'rotate',
		'KeyF': 'drop',
		'KeyG': 'pause',
		'KeyH': 'hold',
		'KeyI': 'up',
		'KeyJ': 'reverse',
		'KeyK': 'rotate',
		'KeyL': 'drop',
		'KeyM': 'drop',
		'KeyO': 'right',
		'KeyP': 'pause',
		'KeyQ': 'reverse',
		'KeyR': 'hold',
		'KeyS': 'down',
		'KeyU': 'left',
		'KeyV': 'hold',
		'KeyW': 'up',
		'KeyX': 'drop',
		'KeyZ': 'reverse',
		'Minus': 'bpf_decrement',
		'NumpadAdd': 'bpf_increment',
		'NumpadDivide': 'delay_decrement',
		'NumpadMultiply': 'delay_increment',
		'NumpadSubtract': 'bpf_decrement',
		'PageDown': 'rotate',
		'PageUp': 'reverse',
		'Pause': 'pause',
		'Period': 'bpf_increment',
		'Semicolon': 'hold',
		'ShiftLeft': 'hold',
		'ShiftRight': 'hold',
		'Space': 'drop',
	}
	static ccw(i){ return (i + N-1) % N }
	static cw(i){ return (i+1) % N }
	constructor(options){
		const o = Object.assign({
			bpf: 1,
			color: {},
			ghost_alpha: 0.4,
			preview: 3,
			sizer: null,
			status: null,
		}, options)
		let { canvas, sizer, status } = o
		if(!sizer){ throw new Error('sizer element required')	}
		if(!status){ throw new Error('status element required')	}
		this.sizer = sizer
		this.status = status
		this.storage = (typeof Storage) && (localStorage instanceof Storage) && localStorage
		this.bpf = o.bpf
		const create_canvas = !canvas
		create_canvas && (canvas = document.createElement('canvas'))
		this.canvas = canvas
		canvas.style.position = 'absolute'
		create_canvas && document.body.appendChild(canvas)
		const c = this.c = canvas.getContext('2d')
		this.color = Object.assign({}, Block.color_default, o.color)
		this.keyhold = {}
		this.keymap = Block.keymap
		document.addEventListener('keydown', e => {
			const action = this.keymap[e.code]
			if(!action || (document.activeElement !== document.body)){
				return
			}
			// if(this.keyhold[e.code]){ return }
			// this.keyhold[e.code] = true
			action && this.input(action, e.repeat)
			if(this.keydown){ return }
			this.keydown = true
			document.querySelectorAll('.touch').forEach(
				el => el.hidden = true
			)
		})
		document.addEventListener('keyup', e => {
			const action = this.keymap[e.code]
			this.keyhold[action] = false
		})
		this.ghost_alpha = o.ghost_alpha
		this.preview = o.preview
		const resize_raf = requestAnimationFrame.bind(null, this.resize.bind(this))
		window.addEventListener('resize', resize_raf)
		this.reset(true)
	}
	input(action, repeat=false){
		const {bag,hold,piece,rot,x,y} = this
		const pd = Block.pb[piece][rot]
		const y_min = Block.y_min[piece][rot]
		let bpf, delay, grav
		switch(action){
			case 'down':
				this.down(1, !repeat)
			break
			case 'left':
				this.can_move(x-1,y,pd,y_min) && (this.x -= 1)
			break
			case 'right':
				this.can_move(x+1,y,pd,y_min) && (this.x += 1)
			break
			case 'up':
				this.grav || this.can_move(x,y-1,pd,y_min) && (this.y -= 1)
			break
			case 'drop':
				this.drop(x,y,pd,y_min)
			break
			case 'hold':
				hold && bag.push(hold)
				this.hold = piece
				this.piece = void 0
				this.store('bag',bag)
				this.store('hold',piece)
			break
			case 'pause':
				grav = !this.grav
			break
			case 'reset':
				this.reset()
			break
			case 'reverse':
				this.rotate(Block.ccw(rot))
			break
			case 'rotate':
				this.rotate(Block.cw(rot))
			break
			case 'bpf_decrement':
				bpf = this.bpf - 1
			break
			case 'bpf_increment':
				bpf = this.bpf + 1
			break
			case 'delay_decrement':
				delay = max(0, this.delay - 100)
			break
			case 'delay_increment':
				delay = this.delay + 100
			break
		}
		this.gravitate(delay, grav, true, bpf)
	}
	can_move(x, y, pd, y_min=0){
		const {field,gh,gw} = this
		let region = 0
		const skip = (y * gw) + x
		for(let i=NN-1; i>=0; --i){
			const xi = x + (i % N)
			const yi = y + floor(i / N)
			if(xi>=0 && yi>=0 && xi<gw && yi<gh){
				region |= field[skip + gw * floor(i / N) + (i % N)] ? 1 : 0
			}
			else if(xi<0 || xi>=gw || yi<y_min || yi>=gh){
				region |= 1
			}
			i && (region <<= 1)
		}
		return !(pd & region)
	}
	dc(x, y, co, opacity=1, grad=false, z=1){
		const {c,g,ghs} = this
		y += ghs
		if(grad){
			const grad = c.createLinearGradient(
				g*x*z,
				g*y*z,
				g*(x+1)*z-1,
				g*(y+1)*z-1,
			)
			grad.addColorStop(0,`rgba(${min(255,co[0]+64)},${min(255,co[1]+64)},${min(255,co[2]+64)},${opacity})`)
			grad.addColorStop(1,`rgba(${max(0,co[0]-64)},${max(0,co[1]-64)},${max(0,co[2]-64)},${opacity})`)
			c.fillStyle = grad
		}
		else{
			c.fillStyle = rgb(co)
		}
		c.fillRect(g*x*z, g*y*z, g*z-1, g*z-1)
	}
	dp(piece, rot, x, y, opacity, z){
		const {color} = this
		let pd = Block.pb[piece][rot]
		let dx = 0
		while(pd){
			;(pd & 1) && this.dc(x + dx, y, color[piece], opacity, true, z)
			dx = (dx+1) % N
			dx || (y += 1)
			pd >>= 1
		}
	}
	down(bpf, can_drop=true){
		const {piece,rot,x,y} = this
		const pd = Block.pb[piece]?.[rot]
		if(!pd){ return }
		const y_min = Block.y_min[piece][rot]
		let can_move
		do{
			can_move = this.can_move(x, y+1, pd, y_min)
			bpf && can_move && (this.y += 1)
		} while(--bpf > 0)
		can_drop && !can_move && this.drop(x,y,pd,y_min)
	}
	drop(x, y, pd, y_min){
		if(!pd){ return }
		while(this.can_move(x,y+1,pd,y_min)){
			y += 1
		}
		const {field,gs,gw} = this
		const ci = Block.ci[this.piece]
		let dx = 0, i, yi = y
		while(pd){
			i = yi*gw + x + dx
			;((i >= 0) && (pd & 1)) && (field[i] = ci)
			dx = (dx+1) % N
			dx || (yi += 1)
			pd >>= 1
		}
		if(yi < 0){ return }
		this.piece = void 0
		i = gs
		let count = 0
		let lines = 0
		while(--i >= 0){
			field[i] && (count += 1)
			if(count === gw){
				for(let j = 0; j < gw; ++j){
					field[i + j] = 0
				}
				const beginning = field.slice(0, i)
				field.set(beginning, gw)
				field.set(new Uint8Array(gw))
				i += gw
				lines += 1
			}
			if(!(i % gw)){ count = 0 }
		}
		this.lines += lines
		this.score += (Block.score[lines] ?? (100 * lines)) + (2 * (y - max(0, this.y)))
		this.store('field',field.map(a=>a?8:0).toBase64())
		this.store('lines',this.lines)
		this.store('score',this.score)
	}
	frame(){
		const {c,color,field,g,gh,ghost_alpha,ghs,gs,gw,h,hold,preview,w} = this
		let {bag,piece,rot,x,y} = this
		const bag_length = bag.length
		c.clearRect(0, 0, w, h)
		c.fillStyle = rgb(color.bg)
		c.fillRect(0, ghs*g, w, gh*g)
		for(let i=gs-1; i>=0; --i){
			field[i] && this.dc(i % gw, floor(i / gw), color[field[i]])
		}
		if(bag_length <= max(1, preview)){
			bag.unshift(...shuffle(Block.pieces.slice(0)))
		}
		if(!piece){
			piece = this.piece = bag.pop()
			rot = this.rot = 0
			x = this.x = 3
			y = this.y = Block.y_init - Block.padt[piece]
		}
		const pd = Block.pb[piece][rot]
		const y_min = Block.y_min[piece][rot]
		if(!this.can_move(x,y,pd,y_min)){
			if(y > -3){
				this.y -= 1
				return this.frame()
			}
			return this.grav && this.gravitate(void 0, false, true)
		}
		this.dp(piece,rot,x,y)
		let y_ghost = y
		while(this.can_move(x,y_ghost+1,pd,y_min)){
			y_ghost += 1
		}
		if(y !== y_ghost){
			this.dp(piece,rot,x,y_ghost,ghost_alpha)
		}
		hold && this.dp(hold,0,0,Block.y_init-Block.padt[hold]-1,1,Block.prev_z)
		x = round(gw / Block.prev_z)
		y = Block.y_init - 1
		bag.slice(-preview).forEach((piece, i) => {
			x += Block.padr[piece] - N
			this.dp(piece,0,x,y-Block.padt[piece],max(.1, 1-(preview-i-1)*.2),Block.prev_z)
			x += Block.padl[piece] - 1
		})
		x = round(gw / Block.prev_z - N)
		this.status.innerHTML = `${
			(this.score+'')}\n${
			(this.lines+'')
		}`
		;(bag_length !== bag.length) && this.store('bag',bag.concat(piece))
	}
	gravitate(delay, grav, clear, bpf){
		if(grav === void 0){ grav = this.grav }
		else{
			this.grav = grav
			eid('grav').checked = grav
			eid('up').style.visibility = grav ? 'hidden' : 'visible'
		}
		if(bpf !== void 0){
			bpf = min(20, max(0, bpf))
			this.bpf = bpf
			eid('bpf').value = bpf
		}
		delay = delay ?? this.delay
		if(this.delay !== delay){
			this.delay = delay
			eid('delay').value = (delay / 1000).toFixed(1)
			this.gravity_loop = this.gravitate.bind(this, delay)
		}
		if(clear || !grav || !delay || (this.delay !== delay)){
			window.clearTimeout(this.timeout)
		}
		if(!grav || !delay){
			this.frame()
			return
		}
		if(!clear){
			this.down(this.bpf)
		}
		this.timeout = window.setTimeout(this.gravity_loop, delay)
		this.frame()
	}
	reset(revive=false){
		this.bag = revive && this.store_get('bag')?.split(',') || []
		this.hold = revive && this.store_get('hold') || void 0
		this.lines = revive && parseInt(this.store_get('lines')) || 0
		this.piece = void 0
		this.score = revive && parseInt(this.store_get('score')) || 0
		const delay = this.delay ?? 1000
		const gh = this.gh = 20
		const ghs = this.ghs = 3
		this.ght = gh + ghs
		const gw = this.gw = 10
		this.resize()
		const gs = this.gs = gh * gw
		this.field = new Uint8Array(gs)
		if(revive){
			const field = this.store_get('field')
			field && this.field.setFromBase64(field)
		}
		this.gravitate(delay, void 0, true, this.bpf)
		this.frame()
	}
	resize(){
		const {c, canvas, ght, gw, sizer} = this
		const rect = sizer.getBoundingClientRect()
		let h = ceil(rect.height)
		let w = ceil(rect.width)
		const g = this.g = min(floor(h/ght), floor(w/gw))
		h = this.h = g * ght
		w = this.w = g * gw
		const x = floor(rect.x)
		const y = floor(rect.y)
		const v_pad = round(((rect.height - h) / 2))
		const scale = window.devicePixelRatio
		canvas.height = h * scale
		canvas.width = w * scale
		canvas.style.height = `${h}px`
		canvas.style.width = `${w}px`
		canvas.style.left = `${x}px`
		canvas.style.top = `${y + v_pad}px`
		c.scale(scale, scale)
		this.field && this.frame()
	}
	rotate(rotb){
		const {piece,rot,x,y} = this
		if('O' === piece){ return }
		const kick = Block.kick[('I'===piece?'I':'J') + rot + rotb]
		const pd = Block.pb[piece][rotb]
		const y_min = Block.y_min[piece][rotb]
		let success, i = 0
		do{
			success = this.can_move(x + kick[i][0], y + kick[i][1], pd, y_min)
			if(success){ break }
		} while(++i !== kick.length)
		if(success){
			this.rot = rotb
			this.x += kick[i][0]
			this.y += kick[i][1]
		}
	}
	store_get(k){
		return this.storage?.getItem(appid+k)
	}
	store(k,v){
		this.storage?.setItem(appid+k,v)
	}
}
function rgb(a){
	return `rgb(${a.join()})`
}
function shuffle(a){
	for(let i = a.length - 1; i > 0; --i){
		const j = floor((i+1) * random())
		const ai = a[i]
		a[i] = a[j]
		a[j] = ai
	}
	return a
}
const game = new Block({
	color:{},
	sizer:eid('wall'),
	status:eid('status'),
})
</script>
