<!doctype html>
<meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0'>
<title>Block Retro</title>
<style>
* {box-sizing:border-box;}
:root {
	--pad: 0px;
	--size:6vh;
	accent-color:#404040;
	color-scheme:dark;
}
body, html, main {height:100%;}
body, button, input {
	font-family:'Roboto Mono','Noto Mono',monospace,system-ui;
	font-size:clamp(10px,2vw,16px);
	line-height:1.5;
}
body {
	background:var(--pi_00);
	border-left: transparent 2px solid;
	display:flex;
	flex-direction:column;
	flex:1;
	margin:0;
	overflow:hidden;
}
body:focus {border-color:var(--pi_10);}
button, label, input {
	cursor:pointer;
	touch-action:manipulation;
	user-select:none;
}
input[type=checkbox]{height:1em;width:1em;}
button, .button {
	background:0;
	border-color:rgba(127,127,127,.5);
	border-width:1px;
}
hr {border-color:var(--pi_3C); border-width:0 1px 0 0;}
input {background:0;border:0;border-radius:0;padding:0;}
input:focus{outline:1px solid;}
.bg2 {background:var(--pi_0F);}
.button {border-style:outset;}
.column {display:flex;flex-direction:column;}
.ctrl, .ctrl svg {height:var(--size);}
.ctrl {
	-webkit-tap-highlight-color:transparent;
	align-self: flex-end;
	fill:var(--pi_3C);
	padding:0;
	user-select:none;
	width:100%;
}
.fade {opacity:.5;}
.grow {flex-grow:1;}
.hotkey {text-decoration:underline dotted;}
.hi {
	color:var(--pi_3C);
	fill:var(--pi_3C);
}
.row {display:flex;}
.text-btn {
	padding:2px 2px 2px 0;
	text-align: right;
}
.uni-btn {line-height:0;}
.wide {width:100%;}
input[type=checkbox]{margin:0 0 0 2px;}
input[type=number]{direction:rtl;}
#status {white-space-collapse:preserve;}
</style>
<body autofocus tabindex='0'>
<main class='row'>
<svg class='grow' viewBox='0 0 88 184'>
	<rect id='wall' x='4' width='80' height='184' fill='transparent'></rect>
	<g transform='translate(0,24)'>
		<rect x='3' width='82' height='160' style='fill:var(--pi_0F)'></rect>
		<path style='fill:var(--pi_3C)' d='m 0,-2 l 1,0 0,1 1,0 0,1 1,0 0,160 -3,0 z'/>
		<path style='fill:var(--pi_3C)' d='m 88,-2 l -1,0 0,1 -1,0 0,1 -1,0 0,160 3,0 z'/>
	</g>
</svg>
<div class='column bg2' style='min-width:7ch;width:var(--size);'>
<div id='status' class='text-btn'></div>
<div class='grow column'>
<label class='button text-btn'>
	Level<br>
	<input id='theme' class='wide' min='0' step='1' onChange='game.set_level(this.value)' type='number' autocomplete='off'>
</label>
<button class='fade ctrl' onPointerDown="game.input('level_increment')" onPointerUp="body.focus();">
	Next
</button>
<label class='fade button text-btn'>
	<span class='hotkey'>G</span>rav<input id='grav' onChange='body.focus();game.gravitate(void 0, this.checked, true)' type='checkbox' autocomplete='off'>
</label>
<label class='fade button text-btn row'>
	<input id='bpf' class='grow' min='0' max='20' step='1' onChange='game.gravitate(void 0, void 0, true, parseInt(this.value))' type='number' autocomplete='off'
	>G
</label>
<label class='fade button text-btn'>
	Delay<br>
	<input id='delay' class='wide' min='0' step='.1' onChange='game.gravitate(1000 * parseFloat(this.value), void 0, true)' type='number' autocomplete='off'>
</label>
<button title='Reset' class='fade ctrl' style='fill:var(--pi_10);' onClick='body.focus();game.reset()'>
	<svg viewBox="0 0 128 128">
		<path d="M108.46,63.96v-25.7c0-1.8-1.7-2.9-3-2l-35,24.4v-22.4c0.13-1.13-0.69-2.15-1.82-2.28
		c-0.45-0.05-0.9,0.05-1.28,0.28l-36.9,25.1v-23.5c0-1.05-0.85-1.9-1.9-1.9h0h-10.2c-1.05,0-1.9,0.85-1.9,1.9l0,0v52.3
		c0,1.05,0.85,1.9,1.9,1.9h0h10.3c1.05,0,1.9-0.85,1.9-1.9l0,0v-23.6l36.9,25c0.98,0.58,2.24,0.26,2.82-0.72
		c0.23-0.39,0.33-0.84,0.28-1.28v-22.3l35,24.4c1.4,0.9,3-0.2,3-2L108.46,63.96z"/>
	</svg>
</button>
<button title='Controls' class='fade ctrl' onClick="doc.querySelectorAll('.touch').forEach(el=>el.hidden=!el.hidden);let t=eid('touch');t.checked=!t.checked;t.checked||body.focus();">
	&vellip;
	<input id='touch' checked hidden type='checkbox'>
</button>
<hr class='grow'>
<button onPointerDown="game.input('left')" class='ctrl touch' aria-label='Left'>
	<svg viewBox="0 0 128 128">
		<path d="M83.72,62.21v-25.7c0.03-1.25-0.96-2.28-2.21-2.31c-0.42-0.01-0.83,0.1-1.19,0.31l-43.5,25.7c-1.13,0.72-1.47,2.22-0.75,3.35c0.19,0.3,0.45,0.55,0.75,0.75l43.5,25.6c1.08,0.63,2.46,0.27,3.09-0.81c0.21-0.36,0.32-0.77,0.31-1.19V62.21z"/>
	</svg>
</button>
<button onPointerDown="game.input('right')" class='ctrl touch' aria-label='Right'>
	<svg viewBox="0 0 128 128">
		<path d="M43.7,62.21v-25.7c-0.03-1.25,0.96-2.28,2.21-2.31c0.42-0.01,0.83,0.1,1.19,0.31l43.5,25.7c1.13,0.72,1.47,2.22,0.75,3.35c-0.19,0.3-0.45,0.55-0.75,0.75l-43.5,25.6c-1.08,0.63-2.46,0.27-3.09-0.81c-0.21-0.36-0.32-0.77-0.31-1.19V62.21z"/>
	</svg>
</button>
<button onPointerDown="game.input('reverse')" class='ctrl touch' aria-label='Reverse'>
	<div class='hi uni-btn' style='font-size:var(--size);'>&#x21b6;</div>
</button>
<button onPointerDown="game.input('rotate')" class='ctrl touch' aria-label='Rotate'>
	<div class='hi uni-btn' style='font-size:var(--size);'>&#x21b7;</div>
</button>
<button onPointerDown="game.input('hold')" class='ctrl touch' aria-label='Hold'>
	<svg viewBox="-16 -16 160 160">
		<path d="M27.3,36.56c0,0,19.47,10.45,20.59,10.95c1.12,0.51,2.64-0.2,3.35-1.83c0.71-1.62,11.16-21.1,11.66-21.91s0.91-2.33,2.74-1.52s4.16-5.27,4.16-5.27L51.13,6.03L41.9,7.25L26.59,34.94L27.3,36.56z"/>
		<path d="M26.38,84.33c0,0,27.18,0.3,28.81,0.3c1.62,0,3.14,0.41,3.35,2.54c0.2,2.13-0.2,26.37-0.2,26.37l-10.45,0.1l-15.52-0.71l-8.32-3.45l-6.49-15.11L26.38,84.33z"/>
		<path d="M107.73,43.86c0,0-21.2,12.48-21.71,12.78s-1.12,1.32-0.2,2.94s11.06,20.08,11.87,21.5c0.81,1.42,1.72,3.14,0.3,4.16c-1.42,1.01,2.13,4.67,2.13,4.67l10.04-1.12l6.8-4.36l5.07-8.42c0,0-0.91-9.94-1.12-10.24c-0.2-0.3-9.43-18.97-9.43-18.97L107.73,43.86z"/>
		<path d="M75.45,37.56c0,0-10.57-16.32-13.97-20.17c-2.67-3.03-5.55-5.51-8.07-7.56c-2.28-1.85-3.95-2.19-5.93-1.88c-3.12,0.49-4.94,1.99-6.69,4.97C35.52,21.87,27.3,36.56,27.3,36.56s-2.89-0.91-2.94-2.84C24.3,31.88,36.12,11.81,37.34,9.68c1.22-2.13,3.25-4.87,8.82-5.17S80.95,4,82.57,4.31s5.38,1.83,8.82,7.1c3.94,6.03,6.45,11.38,6.45,11.38s7.75-4.59,8.56-4.08c1.22,0.76-10.81,24.33-11.77,25.15c-0.6,0.52-27.69,2.23-28.3,0.71C65.94,43.56,75.45,37.56,75.45,37.56z"/>
		<path d="M107.73,43.86c0,0,1.43-1.27,2.57-0.92c1.14,0.36,11.67,22.88,12.72,25.08c1.06,2.2,1.67,7.48-1.58,12.76c-3.26,5.28-18.92,28.87-20.07,30.28c-1.14,1.41-1.76,2.64-4.93,2.64c-3.17,0-15.14-0.18-15.14-0.18s-0.44,8.89-0.53,9.68s-1.41,1.32-2.29-0.26s-13.38-22.71-13.38-23.24c0-0.53,12.23-24.71,14-24.47c1.27,0.18,1.14,9.77,1.14,9.77s27.55-0.53,30.28-0.7c2.73-0.18,5.37-1.23,6.78-3.34s4.58-7.13,2.2-12.32c-2.12-4.62-9.42-18.92-10.47-21.04C108.36,46.27,107.39,44.87,107.73,43.86z"/>
		<path d="M58.33,113.54c-0.39,1.53-1.59,1.57-3,1.66c-1.41,0.09-20.42,0-24.56-0.44c-4.14-0.44-8.1-3.52-9.59-6.95c-1.5-3.43-7.57-14.17-11.79-23.06S4.2,73.31,3.93,71.28s2.02-7.13,4.31-10.83c2.29-3.7,3.87-5.99,3.87-5.99s-8.29-5.46-8.45-6.51c-0.11-0.7,8.35-0.95,15.58-1.23c7.12-0.28,14.35-0.44,14.88,0.09c0.53,0.53,4.31,8.36,6.51,12.85s6.69,12.76,6.6,13.55c-0.13,1.14-1.29,0.57-2.96-0.14c-1.67-0.7-7.86-3.91-7.86-3.91s-6.95,11.88-9.68,17.43c-2.73,5.55-5.37,10.91-4.67,15.84c0.43,2.98,4.05,8.27,10.74,8.98s21.56,0.26,23.33,0.35C57.89,111.86,58.69,112.15,58.33,113.54z"/>
	</svg>
</button>
<button id='up' onPointerDown="game.input('up')" class='ctrl touch' aria-label='Up'>
	<svg viewBox="0 0 128 128">
		<path d="M64,92h29.2c1.48-0.02,2.67-1.23,2.65-2.71c-0.01-0.45-0.12-0.89-0.35-1.29L66.3,37.3c-0.7-1.27-2.31-1.73-3.58-1.02c-0.43,0.24-0.79,0.59-1.02,1.02L32.5,88c-0.73,1.29-0.28,2.92,1.01,3.65c0.39,0.22,0.84,0.34,1.29,0.35H64z"/>
	</svg>
</button>
<button onPointerDown="game.input('down')" class='ctrl touch' aria-label='Down'>
	<svg viewBox="0 0 128 128">
		<path d="M64.2,39.7H34.8c-1.48,0.02-2.67,1.23-2.65,2.71c0.01,0.45,0.12,0.89,0.35,1.29l29.3,51c0.7,1.27,2.31,1.73,3.58,1.02c0.43-0.24,0.79-0.59,1.02-1.02l29.3-51c0.73-1.29,0.28-2.92-1.01-3.65c-0.39-0.22-0.84-0.34-1.29-0.35L64.2,39.7z"/>
	</svg>
</button>
<button onPointerDown="game.input('drop')" class='ctrl touch' aria-label='Drop'>
	<svg viewBox="0 0 128 128">
		<path d="M67.76,61.95h22.3c1.13-0.13,2.15,0.69,2.28,1.82c0.05,0.45-0.05,0.9-0.28,1.28l-25.6,39.9c-0.76,1.1-2.28,1.38-3.38,0.62c-0.24-0.17-0.45-0.38-0.62-0.62l-25.7-39.9c-0.58-0.98-0.26-2.24,0.72-2.82c0.39-0.23,0.84-0.33,1.28-0.28h22.3l-24.4-37c-0.9-1.4,0.2-3,2-3h51.5c1.8,0,2.9,1.7,2,3L67.76,61.95z"/>
	</svg>
</button>
</div></div></main>
<script>
const appid = 'dsblockretro'
const doc = document
const body = doc.body
const {ceil,floor,max,min,random,round} = Math
const eid = doc.getElementById.bind(doc)
const ccw = i => (i+N-1) % N
const cw = i => (i+1) % N
const N = 4
const NN = N * N
const palette = {
	[0x00]:'#626262',
	[0x01]:'#001C95',
	[0x02]:'#1904AC',
	[0x03]:'#42009D',
	[0x04]:'#61006B',
	[0x05]:'#6E0025',
	[0x06]:'#650500',
	[0x07]:'#491E00',
	[0x08]:'#223700',
	[0x09]:'#004900',
	[0x0A]:'#004F00',
	[0x0C]:'#00355E',
	[0x0F]:'#000000',
	[0x10]:'#ABABAB',
	[0x12]:'#3D2EFF',
	[0x13]:'#7115F3',
	[0x14]:'#9B0BB9',
	[0x15]:'#B01262',
	[0x16]:'#A92704',
	[0x17]:'#894600',
	[0x18]:'#576600',
	[0x19]:'#237F00',
	[0x1A]:'#008900',
	[0x1C]:'#006D90',
	[0x20]:'#FFFFFF',
	[0x21]:'#57A5FF',
	[0x22]:'#8287FF',
	[0x24]:'#DF60FF',
	[0x25]:'#F863C6',
	[0x26]:'#F8746D',
	[0x27]:'#DE9020',
	[0x29]:'#81C800',
	[0x2A]:'#56D522',
	[0x2B]:'#3DD36F',
	[0x2D]:'#4E4E4E',
	[0x30]:'#FFFFFF',
	[0x36]:'#FDCACE',
	[0x37]:'#F5D4AF',
	[0x38]:'#E6DF9C',
	[0x3C]:'#B6EAE5',
	[0x3D]:'#B8B8B8',
}
const themes = {
	0:[0x30,0x21,0x12],
	1:[0x30,0x29,0x1A],
	2:[0x30,0x24,0x14],
	3:[0x30,0x2A,0x12],
	4:[0x30,0x2B,0x15],
	5:[0x30,0x22,0x2B],
	6:[0x30,0x00,0x16],
	7:[0x30,0x05,0x13],
	8:[0x30,0x16,0x12],
	9:[0x30,0x27,0x16],
	138:[0x26,0x29,0x25],
	139:[0x09,0x14,0x30],
	140:[0x29,0x30,0x05],
	141:[0x26,0x09,0x25],
	142:[0x09,0x14,0x30],
	143:[0x29,0x30,0x05],
	144:[0x20,0x25,0x09],
	145:[0x20,0x30,0x16],
	146:[0x0F,0x09,0x01],
	147:[0x20,0x25,0x24],
	148:[0x00,0x10,0x0F],
	149:[0x24,0x25,0x37],
	150:[0x25,0x20,0x2B],
	151:[0x05,0x26,0x0C],
	152:[0x18,0x25,0x25],
	153:[0x37,0x10,0x36],
	154:[0x24,0x09,0x1C],
	155:[0x30,0x29,0x00],
	156:[0x24,0x05,0x05],
	157:[0x01,0x29,0x01],
	158:[0x08,0x29,0x05],
	159:[0x00,0x26,0x0F],
	160:[0x16,0x19,0x05],
	161:[0x20,0x29,0x19],
	162:[0x0F,0x09,0x01],
	163:[0x07,0x25,0x26],
	164:[0x0F,0x0C,0x26],
	165:[0x20,0x2B,0x18],
	166:[0x0F,0x29,0x00],
	167:[0x0F,0x20,0x25],
	168:[0x09,0x05,0x10],
	169:[0x26,0x13,0x26],
	170:[0x3D,0x00,0x0F],
	171:[0x0A,0x0A,0x0A],
	172:[0x07,0x2A,0x3D],
	173:[0x19,0x20,0x20],
	174:[0x19,0x20,0x26],
	175:[0x25,0x17,0x18],
	176:[0x1A,0x29,0x07],
	177:[0x07,0x30,0x08],
	178:[0x3D,0x0F,0x19],
	179:[0x19,0x10,0x1C],
	180:[0x17,0x20,0x02],
	181:[0x07,0x2B,0x25],
	182:[0x29,0x07,0x18],
	183:[0x19,0x09,0x07],
	184:[0x06,0x38,0x29],
	185:[0x0C,0x2A,0x19],
	186:[0x3D,0x0F,0x19],
	187:[0x19,0x20,0x00],
	188:[0x00,0x00,0x01],
	189:[0x01,0x01,0x02],
	190:[0x03,0x04,0x04],
	191:[0x05,0x05,0x05],
}
for(const pi in palette){
	const k = `--pi_${parseInt(pi).toString(16).toUpperCase().padStart(2,'0')}`
	doc.documentElement.style.setProperty(k, palette[pi])
}
class Block{
	static ci = {I:1,J:2,L:3,O:4,S:5,T:6,Z:7}
	static level = 120
	static lines_per_level = 4
	static keymap = {
		'ArrowDown': 'down',
		'ArrowLeft': 'left',
		'ArrowRight': 'right',
		'ArrowUp': 'up',
		'Backspace': 'pause',
		'BracketLeft': 'delay_decrement',
		'BracketRight': 'delay_increment',
		'Comma': 'bpf_decrement',
		'Delete': 'reverse',
		'End': 'drop',
		'Enter': 'drop',
		'Equal': 'bpf_increment',
		'Escape': 'pause',
		'F2': 'reset',
		'Home': 'hold',
		'KeyA': 'left',
		'KeyB': 'level_decrement',
		'KeyC': 'rotate',
		'KeyD': 'right',
		'KeyE': 'rotate',
		'KeyF': 'drop',
		'KeyG': 'pause',
		'KeyH': 'hold',
		'KeyI': 'up',
		'KeyJ': 'reverse',
		'KeyK': 'rotate',
		'KeyL': 'drop',
		'KeyM': 'drop',
		'KeyN': 'level_increment',
		'KeyO': 'right',
		'KeyP': 'pause',
		'KeyQ': 'reverse',
		'KeyR': 'hold',
		'KeyS': 'down',
		'KeyU': 'left',
		'KeyV': 'hold',
		'KeyW': 'up',
		'KeyX': 'drop',
		'KeyZ': 'reverse',
		'Minus': 'bpf_decrement',
		'NumpadAdd': 'bpf_increment',
		'NumpadDivide': 'delay_decrement',
		'NumpadMultiply': 'delay_increment',
		'NumpadSubtract': 'bpf_decrement',
		'PageDown': 'rotate',
		'PageUp': 'reverse',
		'Pause': 'pause',
		'Period': 'bpf_increment',
		'Semicolon': 'hold',
		'ShiftLeft': 'hold',
		'ShiftRight': 'hold',
		'Space': 'drop',
	}
	static kick = {
		'I01':[[0,0],[-2,0],[ 1, 0],[-2, 1],[ 1,-2]],
		'I03':[[0,0],[-1,0],[ 2, 0],[-1,-2],[ 2, 1]],
		'I10':[[0,0],[ 2,0],[-1, 0],[ 2,-1],[-1, 2]],
		'I12':[[0,0],[-1,0],[ 2, 0],[-1,-2],[ 2, 1]],
		'I21':[[0,0],[ 1,0],[-2, 0],[ 1, 2],[-2,-1]],
		'I23':[[0,0],[ 2,0],[-1, 0],[ 2,-1],[-1, 2]],
		'I30':[[0,0],[ 1,0],[-2, 0],[ 1, 2],[-2,-1]],
		'I32':[[0,0],[-2,0],[ 1, 0],[-2, 1],[ 1,-2]],
		'J01':[[0,0],[-1,0],[-1,-1],[ 0, 2],[-1, 2]],
		'J03':[[0,0],[ 1,0],[ 1,-1],[ 0, 2],[ 1, 2]],
		'J10':[[0,0],[ 1,0],[ 1, 1],[ 0,-2],[ 1,-2]],
		'J12':[[0,0],[ 1,0],[ 1, 1],[ 0,-2],[ 1,-2]],
		'J21':[[0,0],[-1,0],[-1,-1],[ 0, 2],[-1, 2]],
		'J23':[[0,0],[ 1,0],[ 1,-1],[ 0, 2],[ 1, 2]],
		'J30':[[0,0],[-1,0],[-1, 1],[ 0,-2],[-1,-2]],
		'J32':[[0,0],[-1,0],[-1, 1],[ 0,-2],[-1,-2]],
	}
	static padb = {I:2,J:2,L:2,O:2,S:1,T:2,Z:1}
	static padl = {I:0,J:0,L:0,O:1,S:0,T:0,Z:0}
	static padr = {I:0,J:1,L:1,O:1,S:1,T:1,Z:1}
	static padt = {I:1,J:1,L:1,O:1,S:0,T:1,Z:0}
	static pb = {
		I: [0b00011110000, 0b100010001000100, 0b111100000000, 0b10001000100010],
		J: [0b00001110001, 0b000001000100110, 0b010001110000, 0b00001100100010],
		L: [0b00001110100, 0b000011000100010, 0b000101110000, 0b00001000100011],
		O: [0b11001100000, 0b000011001100000, 0b011001100000, 0b00011001100000],
		S: [0b00000110110, 0b000010001100010, 0b001101100000, 0b00001000110001],
		T: [0b00001110010, 0b000001001100010, 0b001001110000, 0b00001000110010],
		Z: [0b00001100011, 0b000001001100100, 0b011000110000, 0b00000100110010],
	}
	static pieces = Object.keys(Block.pb)
	static ppci = {1:0,2:2,3:1,4:0,5:2,6:0,7:1}
	static ppco = {I:0,J:2,L:1,O:0,S:2,T:0,Z:1}
	static pr = {I:0,J:2,L:2,O:0,S:0,T:2,Z:0}
	static prev_z = 1/4
	static score = {
		1: 100,
		2: 300,
		3: 500,
		4: 800,
	}
	static y_init = 0
	static y_min = {
		I: [-1, -4, -1, -4],
		J: [-2, -3, -2, -3],
		L: [-2, -3, -2, -3],
		O: [-2, -2, -2, -2],
		S: [-2, -3, -2, -3],
		T: [-2, -3, -2, -3],
		Z: [-2, -3, -2, -3],
	}
	constructor(options){
		const o = Object.assign({
			bpf: 1,
			ghost_alpha: 0.5,
			preview: 1,
			sizer: null,
			status: null,
		}, options)
		let { canvas, sizer, status } = o
		if(!sizer){ throw new Error('sizer element required')	}
		if(!status){ throw new Error('status element required')	}
		this.sizer = sizer
		this.status = status
		this.storage = (typeof Storage) && (localStorage instanceof Storage) && localStorage
		this.bpf = o.bpf
		const create_canvas = !canvas
		create_canvas && (canvas = doc.createElement('canvas'))
		this.canvas = canvas
		canvas.style.position = 'absolute'
		create_canvas && body.appendChild(canvas)
		const c = this.c = canvas.getContext('2d')
		this.keyhold = {}
		this.keymap = Block.keymap
		doc.addEventListener('keydown', e => {
			const action = this.keymap[e.code]
			if(!action || (doc.activeElement !== body)){
				return
			}
			action && this.input(action, e.repeat)
			if(this.keydown){ return }
			this.keydown = true
			doc.querySelectorAll('.touch').forEach(
				el => el.hidden = true
			)
		})
		doc.addEventListener('keyup', e => {
			const action = this.keymap[e.code]
			this.keyhold[action] = false
		})
		this.ghost_alpha = o.ghost_alpha
		this.preview = o.preview
		const resize_raf = requestAnimationFrame.bind(null, this.resize.bind(this))
		window.addEventListener('resize', resize_raf)
		this.reset(true)
	}
	input(action, repeat=false){
		const {bag,hold,piece,rot,x,y} = this
		const pd = Block.pb[piece][rot]
		const y_min = Block.y_min[piece][rot]
		let bpf, delay, grav
		switch(action){
			case 'down':
				this.down(1, !repeat)
			break
			case 'left':
				this.can_move(x-1,y,pd,y_min) && (this.x -= 1)
			break
			case 'right':
				this.can_move(x+1,y,pd,y_min) && (this.x += 1)
			break
			case 'up':
				this.grav || this.can_move(x,y-1,pd,y_min) && (this.y -= 1)
			break
			case 'drop':
				this.drop(x,y,pd,y_min)
			break
			case 'hold':
				hold && bag.push(hold)
				this.hold = piece
				this.piece = void 0
				this.store('bag',bag)
				this.store('hold',this.hold)
			break
			case 'pause':
				grav = !this.grav
			break
			case 'reset':
				this.reset()
			break
			case 'reverse':
				this.rotate(ccw(rot))
			break
			case 'rotate':
				this.rotate(cw(rot))
			break
			case 'bpf_decrement':
				bpf = this.bpf - 1
			break
			case 'bpf_increment':
				bpf = this.bpf + 1
			break
			case 'delay_decrement':
				delay = max(0, this.delay - 100)
			break
			case 'delay_increment':
				delay = this.delay + 100
			break
			case 'level_decrement':
				this.set_theme(this.level - 1)
			break
			case 'level_increment':
				this.set_theme(this.level + 1)
			break
			default: return
		}
		this.gravitate(delay, grav, true, bpf)
	}
	can_move(x, y, pd, y_min=0){
		const {field,gh,gw} = this
		let region = 0
		const skip = (y * gw) + x
		for(let i=NN-1; i>=0; --i){
			const xi = x + (i % N)
			const yi = y + floor(i / N)
			if(xi>=0 && yi>=0 && xi<gw && yi<gh){
				region |= field[skip + gw * floor(i / N) + (i % N)] ? 1 : 0
			}
			else if(xi<0 || xi>=gw || yi<y_min || yi>=gh){
				region |= 1
			}
			i && (region <<= 1)
		}
		return !(pd & region)
	}
	dc(x, y, ti, opacity=1, z=1){
		const {c,g,g16,g8,ghs,theme} = this
		const pi = theme[ti], pi_0 = theme[0], pi_1 = theme[1], pi_2 = theme[2]
		const z1 = (pi_0 == pi_1), z2 = (pi_0 == pi_2), m0 = (pi_0 == pi),
			ti0 = ti === 0, ti1 = ti === 1, ti2 = ti === 2
		let xi, yi
		y += ghs
		c.save()
		c.globalAlpha = opacity
		c.lineWidth = g8 * z
		if(ti0 && !z2){
			c.strokeStyle = palette[pi_2]
			c.beginPath()
			c.moveTo((xi=x*g+g8)*z, (yi=y*g+g16)*z)
			c.lineTo((xi+=11*g16)*z, yi*z)
			c.lineTo(xi*z, (yi+=12*g16)*z)
			c.lineTo((xi-=12*g16)*z, yi*z)
			c.lineTo(xi*z, (yi-11*g16)*z)
			c.stroke()
		}
		c.fillStyle = palette[pi]
		if(ti0 && !z2){
			c.fillRect((1 + x*8)*g8*z, (1 + y*8)*g8*z, 5*g8*z, 5*g8*z)
		}
		if(!ti0 && !m0){
			c.beginPath()
			c.moveTo((xi=x*g+g8)*z, (yi=y*g)*z)
			c.lineTo((xi+=6*g8)*z, yi*z)
			c.lineTo(xi*z, (yi+=7*g8)*z)
			c.lineTo((xi-=7*g8)*z, yi*z)
			c.lineTo(xi*z, (yi-=6*g8)*z)
			c.lineTo((xi+=g8)*z, yi*z)
			c.fill()
		}
		if(!ti0 && !m0){
			c.strokeStyle = palette[pi_0]
			c.beginPath()
			c.moveTo((xi=x*g+g8+g16)*z, (yi=y*g+3*g8)*z)
			c.lineTo(xi*z, (yi-=g8+g16)*z)
			c.lineTo((xi+g8+g16)*z, yi*z)
			c.stroke()
		}
		if((!ti1 && !z2) || (ti1 && !z1)){
			c.fillStyle = palette[pi_0]
			c.fillRect(x*g*z, y*g*z, g8*z, g8*z)
		}
		if((!ti1 && z2) || (ti1 && z1)){
			c.fillRect(x*g*z, y*g*z, 7*g8*z, 7*g8*z)
		}
		c.restore()
	}
	dp(piece, rot, x, y, opacity, z){
		let pd = Block.pb[piece][rot]
		let dx = 0
		while(pd){
			;(pd & 1) && this.dc(x + dx, y, Block.ppco[piece], opacity, z)
			dx = (dx+1) % N
			dx || (y += 1)
			pd >>= 1
		}
	}
	down(bpf, can_drop=true){
		const {piece,rot,x,y} = this
		const pd = Block.pb[piece]?.[rot]
		if(!pd){ return }
		const y_min = Block.y_min[piece][rot]
		let can_move
		do{
			can_move = this.can_move(x, y+1, pd, y_min)
			bpf && can_move && (this.y += 1)
		} while(--bpf > 0)
		can_drop && !can_move && this.drop(x,y,pd,y_min)
	}
	drop(x, y, pd, y_min){
		if(!pd){ return }
		while(this.can_move(x,y+1,pd,y_min)){
			y += 1
		}
		const {field,gs,gw} = this
		const ci = Block.ci[this.piece]
		let dx = 0, i, yi = y
		while(pd){
			i = yi*gw + x + dx
			;((i >= 0) && (pd & 1)) && (field[i] = ci)
			dx = (dx+1) % N
			dx || (yi += 1)
			pd >>= 1
		}
		if(yi < 0){ return }
		this.piece = void 0
		i = gs
		let count = 0
		let lines = 0
		while(--i >= 0){
			field[i] && (count += 1)
			if(count === gw){
				for(let j = 0; j < gw; ++j){
					field[i + j] = 0
				}
				const beginning = field.slice(0, i)
				field.set(beginning, gw)
				field.set(new Uint8Array(gw))
				i += gw
				lines += 1
			}
			if(!(i % gw)){ count = 0 }
		}
		const level_delta = floor((this.lines + lines) / Block.lines_per_level) - floor(this.lines / Block.lines_per_level)
		level_delta && this.set_theme(this.level + level_delta)
		this.lines += lines
		this.score += (Block.score[lines] ?? (100 * lines)) + (2 * (y - max(0, this.y)))
		this.store('field',field.toBase64())
		this.store('lines',this.lines)
		this.store('score',this.score)
	}
	frame(){
		const pz = Block.prev_z
		const {c,field,g,g8,gh,ghost_alpha,ghs,gs,gw,h,hold,preview,w} = this
		let {bag,piece,rot,x,y} = this
		const bag_length = bag.length
		c.clearRect(0, 0, w, h)
		c.fillStyle = palette[0x0F]
		for(let i=gs-1; i>=0; --i){
			field[i] && this.dc(i % gw, floor(i / gw), Block.ppci[field[i]])
		}
		if(bag_length <= max(1, preview)){
			bag.unshift(...shuffle(Block.pieces.slice(0)))
		}
		if(!piece){
			piece = this.piece = bag.pop()
			rot = this.rot = Block.pr[piece]
			x = this.x = 3
			y = this.y = Block.y_init - Block.padt[piece]
		}
		const pd = Block.pb[piece][rot]
		const y_min = Block.y_min[piece][rot]
		if(!this.can_move(x,y,pd,y_min)){
			if(y > -3){
				this.y -= 1
				return this.frame()
			}
			return this.grav && this.gravitate(void 0, false, true)
		}
		this.dp(piece,rot,x,y)
		let y_ghost = y
		while(this.can_move(x,y_ghost+1,pd,y_min)){
			y_ghost += 1
		}
		if(y !== y_ghost){
			this.dp(piece,rot,x,y_ghost,ghost_alpha)
		}
		c.strokeStyle = palette[0x3C]
		c.beginPath();c.rect(g8, g8, 10*g8, N*g*pz);c.stroke();c.fill()
		y = Block.y_init - .5
		hold && this.dp(hold,Block.pr[hold],1,y-Block.padb[hold],1,pz)
		c.beginPath();c.rect(gw*g-g8, g8, -10*g8, N*g*pz);c.stroke();c.fill()
		x = round(gw / pz) - 1
		bag.slice(-preview).forEach((piece, i) => {
			const padb = Block.padb[piece]
			const padl = Block.padl[piece]
			const padr = Block.padr[piece]
			x += Block.padr[piece] - N
			this.dp(piece,Block.pr[piece],x,y-padb,void 0,pz)
			x += padl - 1
		})
		x = round(gw / pz - N)
		this.status.innerHTML = `${
			(this.score+'')}\n${
			(this.lines+'')
		}`
		;(bag_length !== bag.length) && this.store('bag',bag.concat(piece))
	}
	gravitate(delay, grav, clear, bpf){
		if(grav === void 0){ grav = this.grav }
		else{
			this.grav = grav
			eid('grav') && (eid('grav').checked = grav)
			eid('up') && (eid('up').style.visibility = grav ? 'hidden' : 'visible')
		}
		if(bpf !== void 0){
			bpf = min(20, max(0, bpf))
			this.bpf = bpf
			eid('bpf').value = bpf
		}
		delay = delay ?? this.delay
		if(this.delay !== delay){
			this.delay = delay
			eid('delay').value = (delay / 1000).toFixed(1)
			this.gravity_loop = this.gravitate.bind(this, delay)
		}
		if(clear || !grav || !delay || (this.delay !== delay)){
			window.clearTimeout(this.timeout)
		}
		if(!grav || !delay){
			this.frame()
			return
		}
		if(!clear){
			this.down(this.bpf)
		}
		this.timeout = window.setTimeout(this.gravity_loop, delay)
		this.frame()
	}
	reset(revive=false){
		this.bag = revive && this.store_get('bag')?.split(',') || []
		this.hold = revive && this.store_get('hold') || void 0
		this.lines = revive && parseInt(this.store_get('lines')) || 0
		this.piece = void 0
		this.score = revive && parseInt(this.store_get('score')) || 0
		this.set_theme(Block.level + this.lines / Block.lines_per_level)
		const delay = this.delay ?? 1000
		const gh = this.gh = 20
		const ghs = this.ghs = 3
		this.ght = gh + ghs
		const gw = this.gw = 10
		this.resize()
		const gs = this.gs = gh * gw
		this.field = new Uint8Array(gs)
		if(revive){
			const field = this.store_get('field')
			field && this.field.setFromBase64(field)
		}
		this.gravitate(delay, void 0, true, this.bpf)
		this.frame()
	}
	resize(){
		const {c, canvas, ght, gw, sizer} = this
		const rect = sizer.getBoundingClientRect()
		let h = rect.height
		let w = rect.width
		let g = min(h/ght, w/gw)
		const g8 = this.g8 = g/8
		this.g16 = g/16
		this.g = g
		h = this.h = g * ght
		w = this.w = g * gw
		const x = floor(rect.x)
		const y = floor(rect.y)
		const scale = window.devicePixelRatio
		canvas.height = h * scale
		canvas.width = w * scale
		canvas.style.height = `${h}px`
		canvas.style.left = `${x}px`
		canvas.style.top = `${y}px`
		canvas.style.width = `${w}px`
		c.lineWidth = g8
		c.scale(scale, scale)
		this.field && this.frame()
	}
	rotate(rotb){
		const {piece,rot,x,y} = this
		if('O' === piece){ return }
		const kick = Block.kick[('I'===piece?'I':'J') + rot + rotb]
		const pd = Block.pb[piece][rotb]
		const y_min = Block.y_min[piece][rotb]
		let success, i = 0
		do{
			success = this.can_move(x + kick[i][0], y + kick[i][1], pd, y_min)
			if(success){ break }
		} while(++i !== kick.length)
		if(success){
			this.rot = rotb
			this.x += kick[i][0]
			this.y += kick[i][1]
		}
	}
	set_level(t){
		t = parseInt(t)
		if(isNaN(t)) return
		this.set_theme(t)
		this.frame()
	}
	set_theme(t){
		t ??= this.level ?? Block.level
		t = floor((t + 256) % 256)
		eid('theme').value = this.level = t
		if(t <= 137){ t %= 10 }
		if((t >= 192) && (t <= 201)){ t -= 192 }
		if(t >= 202){ t -= 64 }
		this.theme = themes[t]
	}
	store_get(k){
		return this.storage?.getItem(appid+k)
	}
	store(k,v){
		this.storage?.setItem(appid+k,v)
	}
}
function shuffle(a){
	for(let i = a.length - 1; i > 0; --i){
		const j = floor((i+1) * random())
		const ai = a[i]
		a[i] = a[j]
		a[j] = ai
	}
	return a
}
const game = new Block({
	sizer:eid('wall'),
	status:eid('status'),
})
</script>
