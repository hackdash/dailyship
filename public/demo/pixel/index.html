<!doctype html>
<html lang="en">
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Draw, fill, color picker, flip, palette, export PNG" />
<title>Pixel Art Studio Silver</title>
<style>
  :root {
    --accent: hsl(240, 30%, 40%);
    --danger: hsl(0, 40%, 40%);
    --danger-soft-hover: hsl(0, 30%, 40%);
    --danger-soft: hsl(0, 20%, 40%);
    --dark: hsl(0, 0%, 20%);
    --line: rgba(50, 50, 50);
    --primary: hsl(120, 10%, 10%);
    --secondary: hsl(150, 10%, 10%);
    accent-color: var(--accent);
    color-scheme: dark;
  }

  * {
    box-sizing: border-box;
    font-family:
      Roboto,
      system-ui,
      -apple-system,
      "Segoe UI",
      sans-serif;
    font-size: 1em;
    margin: 0;
    padding: 0;
  }

  body {
    align-items: flex-start;
    /* justify-content: center; */
    min-height: 100vh;
    padding: 0;
  }

  button {
    text-align: left;
  }

  input[type=number] {
    text-align: right;
  }

  p {
    line-height: 1.5;
    padding: 0 0.5em;
  }

  pre {
    font-family: "Roboto Mono", monospace;
    white-space-collapse: preserve;
    white-space: pre;
  }

  .main {
    margin: auto;
  }

  .border,
  .pixel-canvas,
  .control-group,
  .custom-select,
  .modal,
  .status-pill,
  .swatch {
    border-color: var(--line);
    border-style: solid;
    border-width: 1px;
  }

  .column {
    display: flex;
    flex-direction: column;
  }

  .grow {
    flex-grow: 1;
  }

  .high {
    margin: 1px 0;
  }

  .mono,
  .row {
    display: flex;
    gap: 0.5em;
  }

  .spacer {
    margin-top: 0.5em;
  }

  .wide {
    width: 100%;
  }

  .wrap {
    flex-wrap: wrap;
  }

  .brandbar__link {
    opacity: .5;
    text-decoration: none;
  }

  .pixel-canvas {
    display: block;
    margin: 0.5em 0 0;
    max-width: 100%;
    touch-action: none;
  }

  .round,
  .custom-select,
  .modal,
  .status-pill {
    border-radius: 1em;
  }

  .btn-row {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25em;
    margin-bottom: 0.5em;
  }

  .canvas-wrapper {
    margin: 0 auto;
    max-width: 100%;
  }

  .control-shell {
    max-width: 13.5em;
  }

  .control-group {
    border-width: 0 0 1px;
    overflow: hidden;
    padding: 0.5em;
  }

  .control-group__title {
    font-weight: 900;
    margin-bottom: 0.5em;
  }

  .control-label {
    display: flex;
    gap: 0.25em;
    white-space: nowrap;
  }

  .custom-select {
    background: #202020;
    cursor: pointer;
    padding: 0 0.5em;
  }

  .color-input {
    background: 0;
    border: none;
    cursor: pointer;
    height: 2em;
    padding: 0;
  }

  .status-pill {
    align-items: center;
    border-color: var(--line);
    display: inline-flex;
    line-height: 2;
    padding: 0 0.5em;
  }

  .tool-button,
  .high {
    line-height: 2;
  }

  .tool-button {
    background: var(--primary);
    border-radius: 0.25em;
    border-width: 1px;
    cursor: pointer;
    padding: 0 0.5em;
    transition:
      transform 0.15s ease,
      background 0.15s ease,
      filter 0.15s ease;
    user-select: none;
  }

  .tool-button:hover {
    background: var(--secondary);
  }

  .tool-button.active {
    background: var(--accent);
    border-style: inset;
  }

  .tool-button.danger {
    background: var(--danger);
  }

  .tool-button.danger:hover {
    filter: brightness(0.98);
  }

  .tool-button.danger-soft {
    background: var(--danger-soft);
  }

  .tool-button.danger-soft:hover {
    background: var(--danger-soft-hover);
  }

  .swatch,
  .swatches {
    display: grid;
    height: 5em;
    grid-template-columns: repeat(4, min-content);
    grid-template-rows: repeat(2, min-content);
  }

  .swatch {
    border-radius: 0.5em;
    /* box-shadow: 0 1px 0.5em rgba(127, 127, 127, 0.25); */
    cursor: pointer;
    height: 2.5em;
    position: relative;
    width: 2.5em;
  }

  .swatch:focus {
    outline: 0.25em solid;
    outline-color: var(--accent);
    outline-offset: 2px;
  }

  .swatch--empty {
    background:
      linear-gradient(45deg,
        rgba(127, 127, 127, 0.1) 25%,
        transparent 25%),
      linear-gradient(-45deg,
        rgba(127, 127, 127, 0.1) 25%,
        transparent 25%),
      linear-gradient(45deg,
        transparent 75%,
        rgba(127, 127, 127, 0.1) 75%),
      linear-gradient(-45deg,
        transparent 75%,
        rgba(127, 127, 127, 0.1) 75%);
    background-position:
      0 0,
      0 0.5em,
      0.5em -0.5em,
      -0.5em 0;
    background-size: 0.5em 0.5em;
  }

  .swatch--selected::after {
    border-radius: 0.5em;
    border: 0.25em solid;
    border-color: var(--accent);
    content: "";
    inset: -3px;
    position: absolute;
  }

  .modal-overlay[open] {
    display: grid;
  }

  .modal-overlay {
    background: rgba(0, 0, 0, 0.5);
    border: 0;
    height: 100vh;
    padding: 1.5em;
    place-items: center;
    width: 100vw;
  }

  .modal {
    background: hsl(0, 0%, 30%);
    box-shadow: 0 1.5em 3em rgba(0, 0, 0, 0.5);
    max-width: 30em;
    overflow: hidden;
    width: 100%;
  }

  .modal__head {
    align-items: center;
    display: flex;
    justify-content: space-between;
    padding: 0.75em 1.25em;
  }

  .modal__text {
    padding: 0;
  }

  .modal__title {
    font-weight: 900;
  }

  .modal__body {
    padding: 1em;
  }

  .modal__actions {
    display: flex;
    gap: 0.5em;
    padding: 0.75em 1.25em;
  }
</style>

<body class="column">
  <main class="row wrap main">
    <section class="control-shell column wrap" aria-label="Controls">
      <div class="control-group" aria-label="Canvas settings">
        <div class="control-group__title row">
          <span class="high">Canvas</span>
          <button id="newProjectBtn" class="tool-button danger-soft grow">
            <u>N</u>ew
          </button>
        </div>

        <label class="control-label high">
          <span class="high">Size</span>
          <input id="gridSize" class="status-pill" disabled autocomplete="off" size="2" type="number">
        </label>

        <div class="row">
          <label class="control-label high">
            Grid
            <input id="toggleGrid" checked type="checkbox" />
          </label>
          <label class="control-label grow">
            <input class="grow" id="gridOpacity" value="32" max="255" min="0" style="width:0" type="range" autocomplete="off" />
          </label>
        </div>
      </div>

      <div class="control-group" aria-label="Tools">
        <label class="control-label">
          <div class="high">Brush</div>
          <input id="brushSize" class="status-pill" value="1" max="99" min="1" size="2" autocomplete="off"
            type="number">
        </label>
        <div class="btn-row spacer">
          <button id="drawTool" class="tool-button active">
            <u>D</u>raw
          </button>
          <button id="eraseTool" class="tool-button">
            <u>E</u>rase
          </button>
          <button id="fillTool" class="tool-button">
            <u>F</u>ill
          </button>
          <button id="pickTool" class="tool-button">
            P<u>i</u>ck
          </button>
        </div>
        <div class="btn-row">
          <button id="undoBtn" class="tool-button" title="Cmd+Z">
            Undo
          </button>
          <button id="redoBtn" class="tool-button" title="Cmd+Shift+Z or Cmd+Y">
            Redo
          </button>
          <button id="clearBtn" class="tool-button danger">
            Clear
          </button>
        </div>
        <!-- <div class="btn-row"> -->
        <!-- <div class="control-group__title high">Flip</div> -->
        <!-- <button id="flipHBtn" class="tool-button"> -->
        <!-- <u>H</u>orizontal -->
        <!-- </button> -->
        <!-- <button id="flipVBtn" class="tool-button"> -->
        <!-- <u>V</u>ertical -->
        <!-- </button> -->
        <!-- </div> -->
      </div>
      <div class="control-group" aria-label="Export">
        <div class="control-group__title">
          <button id="exportPNG" class="tool-button wide danger" title="Cmd+S">
            Export PNG
          </button>
        </div>
        <label class="control-label">
          <div class="high">Scale</div>
          <input id="exportScale" class="status-pill" value="1" step="1" min="1" size="2" type="number">
        </label>
      </div>
      <div class="control-group" aria-label="Palette">
        <label class="control-group__title control-label">
          <span class="high">Color</span>
          <input autocomplete="off" class="color-input wide" id="colorPicker" type="color" value="#000000" />
        </label>
        <label class="control-group__title control-label">
          <span class="high">Opacity</span>
          <input class="grow" id="opacity" value="255" max="255" min="0" style="width:0" type="range" autocomplete="off" />
        </label>
        <div id="recentSwatches" class="swatches" aria-label="Recent colors"></div>
        <div class="control-label high">Saved</div>
        <div aria-label="Saved colors" class="swatches" id="savedSwatches"></div>
      </div>
      <div class="control-group">
        <div class="mono row wide wrap spacer" aria-label="Status">
          <span class="status-pill" id="statusTool" style="width: 3.5em">Draw</span>
          <pre class="status-pill" id="statusCell" style="width: 5em">&nbsp;</pre>
        </div>
      </div>
      <div class="control-group">
        <p>
          <a class="brandbar__link row" href="https://github.com/TABARC-Code/pixel-art-studio" target="_blank"
            rel="noreferrer">
            <b>TABARC</b>
            Pixel Art Studio
          </a>
        </p>
        <p>
          <a class="brandbar__link row" href="https://dailyship.org/" target="_blank" rel="noreferrer">
            <b>DailyShip</b>
            Silver Edition
          </a>
        </p>
      </div>
    </section>
    <section class="canvas-wrapper" aria-label="Canvas">
      <canvas id="pixelCanvas" class="pixel-canvas" aria-label="Pixel drawing canvas"></canvas>
    </section>
  </main>
  <dialog id="modalOverlay" class="modal-overlay">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modal__head">
        <div class="modal__title" id="modalTitle">New Canvas</div>
      </div>
      <div class="modal__body">
        <label class="control-label">
          <span class="high">Canvas Size</span>
          <select id="modalGridSize" class="custom-select">
            <option value="16">16</option>
            <option value="32">32</option>
            <option value="64">64</option>
          </select>
        </label>
      </div>
      <div class="modal__actions">
        <button id="modalCancel" class="tool-button">
          Cancel
        </button>
        <button id="modalConfirm" class="tool-button danger">
          Start New
        </button>
      </div>
    </div>
  </dialog>
  <script>
    const eid = document.getElementById.bind(document);
    const h = document.createElement.bind(document);

    const cast = (c) => (c < 0) ? (c + 0x100000000) : c;

    // Transform char code to its hexadecimal value
    const hd = (c) => (c & 0xf) + 9 * (c >> 6);

    function colorInt(s) {
      const r = hd(s.charCodeAt(1)) << 4 | hd(s.charCodeAt(2))
      const g = hd(s.charCodeAt(3)) << 4 | hd(s.charCodeAt(4))
      const b = hd(s.charCodeAt(5)) << 4 | hd(s.charCodeAt(6))
      const a = hd(s.charCodeAt(7)) << 4 | hd(s.charCodeAt(8))
      return (r << 24) | (g << 16) | (b << 8) | (a << 0)
    }

    function colorStr(c) {
      return `#${(cast(c)).toString(16).padStart(8, '0')}`
    }

    class PixelArtStudio {
      constructor() {
        this.canvas = eid("pixelCanvas");
        this.ctx = this.canvas.getContext("2d", {
          willReadFrequently: true,
        });
        this.brushSize = 1;
        this.gridOpacity = 32;
        this.gridSize = 16;
        this.hoverCell = void 0;
        this.isPointerDown = false;
        this.lastPaintedKey = void 0;
        this.maxHistory = 60;
        this.maxRecent = 8;
        this.opacity = 255;
        this.pal = {};
        this.pixels = void 0;
        this.pixelSize = 20;
        this.recentColors = [];
        this.redoStack = [];
        this.savedSlots = Array(8).fill(0);
        this.showGrid = true;
        this.tool = "draw"; // draw | erase | fill | pick
        this.undoStack = [];

        this.ui = Object.fromEntries([
          "brushSize",
          "clearBtn",
          "colorPicker",
          "drawTool",
          "eraseTool",
          "exportPNG",
          "exportScale",
          "fillTool",
          "flipHBtn",
          "flipVBtn",
          "gridOpacity",
          "gridSize",
          "modalCancel",
          "modalConfirm",
          "modalGridSize",
          "modalOverlay",
          "newProjectBtn",
          "opacity",
          "pickTool",
          "recentSwatches",
          "redoBtn",
          "savedSwatches",
          "statusCell",
          "statusTool",
          "toggleGrid",
          "undoBtn",
        ].map(id => [id, eid(id)]))

        this.init();
        this.bindEvents();
      }

      init() {
        this.ui.gridSize.value = this.gridSize;
        this.setColor(0xFFFFFFFF);
        this.loadSavedSlots();
        this.allocatePixelBuffer();
        this.adjustCanvasSize();
        this.pushHistory("init");
        this.renderPalette();
        this.updateStatus();
        this.render();
      }

      idx(x, y) {
        return this.gridSize * y + x;
      }

      getX(i) {
        return i % this.gridSize;
      }

      getY(i) {
        return Math.floor(i / this.gridSize);
      }

      allocatePixelBuffer() {
        this.pixels = new Int32Array(this.gridSize * this.gridSize);
      }

      adjustCanvasSize() {
        const maxCanvasPx = 720;
        const g = this.gridSize;
        const s = this.pixelSize = Math.max(
          1,
          Math.floor(maxCanvasPx / this.gridSize),
        );
        this.canvas.height = g * s;
        this.canvas.width = g * s;
        this.ctx.imageSmoothingEnabled = false;
      }

      setBrush(value) {
        this.brushSize = Math.max(1, Math.min(99, parseInt(value)));
        this.ui.brushSize.value = this.brushSize;
      };

      bindEvents() {
        const { ui } = this
        const { brushSize } = ui
        ui.colorPicker.addEventListener("change", (e) => {
          this.setColor(colorInt(e.target.value) + this.opacity, true);
        });

        brushSize.addEventListener("blur", (e) => this.setBrush(e.target.value));
        brushSize.addEventListener("change", (e) => this.setBrush(e.target.value));
        brushSize.addEventListener("focus", (e) => brushSize.select());

        ui.drawTool.addEventListener("click", () =>
          this.setTool("draw"),
        );
        ui.fillTool.addEventListener("click", () =>
          this.setTool("fill"),
        );
        ui.eraseTool.addEventListener("click", () =>
          this.setTool("erase"),
        );
        ui.pickTool.addEventListener("click", () =>
          this.setTool("pick"),
        );

        ui.toggleGrid.addEventListener("change", (e) => {
          this.showGrid = e.target.checked;
          this.updateStatus();
          this.render();
        });

        ui.gridOpacity.addEventListener("input", (e) => {
          this.gridOpacity = parseInt(e.target.value);
          this.render();
        });
        ui.opacity.addEventListener("input", (e) => {
          this.opacity = parseInt(e.target.value);
          this.setColor(
            (this.currentColor & 0xFFFFFF00) + this.opacity
          );
        });

        ui.undoBtn.addEventListener("click", () =>
          this.undo(),
        );
        ui.redoBtn.addEventListener("click", () =>
          this.redo(),
        );

        ui.clearBtn.addEventListener("click", () => {
          this.pushHistory("clear");
          this.clearPixels();
          this.render();
        });

        // ui.flipHBtn.addEventListener("click", () =>
        //   this.flipHorizontal(),
        // );
        // ui.flipVBtn.addEventListener("click", () =>
        //   this.flipVertical(),
        // );

        ui.exportPNG.addEventListener("click", () =>
          this.exportPNG(),
        );

        // Modal events
        ui.newProjectBtn.addEventListener("click", () =>
          this.openModal(),
        );
        ui.modalCancel.addEventListener("click", () =>
          this.closeModal(),
        );
        ui.modalOverlay.addEventListener("click", (e) => {
          if (e.target === ui.modalOverlay)
            this.closeModal();
        });
        ui.modalConfirm.addEventListener("click", () =>
          this.confirmNewProject(),
        );

        // Pointer events
        this.canvas.addEventListener("pointerdown", (e) =>
          this.onPointerDown(e),
        );
        this.canvas.addEventListener("pointermove", (e) =>
          this.onPointerMove(e),
        );
        this.canvas.addEventListener("pointerup", () =>
          this.onPointerUp(),
        );
        this.canvas.addEventListener("pointercancel", () =>
          this.onPointerUp(),
        );
        this.canvas.addEventListener("pointerleave", () =>
          this.onPointerLeave(),
        );

        // Keyboard shortcuts
        window.addEventListener("keydown", (e) =>
          this.onKeyDown(e),
        );
      }

      onKeyDown(e) {
        const tag =
          e.target && e.target.tagName
            ? e.target.tagName.toLowerCase()
            : "";
        if (
          tag === "input" ||
          tag === "select" ||
          tag === "textarea"
        )
          return;

        // Modal: Keys for open dialog, ignoring all else.
        if (this.ui.modalOverlay.open) {
          if (e.key === "Escape") {
            e.preventDefault();
            this.closeModal();
          }
          if (e.key === "Enter") {
            e.preventDefault();
            this.confirmNewProject();
          }
          return;
        }

        const key = e.key.toLowerCase();
        const mod = e.ctrlKey || e.metaKey;

        if (mod && key === "z" && !e.shiftKey) {
          e.preventDefault();
          this.undo();
          return;
        }

        if (
          (mod && key === "y") ||
          (mod && key === "z" && e.shiftKey)
        ) {
          e.preventDefault();
          this.redo();
          return;
        }

        if (mod && key === "s") {
          e.preventDefault();
          this.exportPNG();
          return;
        }

        if (key === "g") {
          this.ui.toggleGrid.checked =
            !this.ui.toggleGrid.checked;
          this.ui.toggleGrid.dispatchEvent(new Event("change"));
        }

        if (key === "[") { this.setBrush(this.brushSize - 1); return; }
        if (key === "]") { this.setBrush(this.brushSize + 1); return; }
        if (key === "d") { this.setTool("draw"); return; }
        if (key === "e") { this.setTool("erase"); return; }
        if (key === "f") { this.setTool("fill"); return; }
        if (key === "h") { this.flipHorizontal(); return; }
        if (key === "i") { this.setTool("pick"); return; }
        if (key === "n") { this.openModal(); return; }
        if (key === "v") { this.flipVertical(); return; }
      }

      setGridSize(gridSize, destructive = true) {
        this.ui.gridSize.value = this.gridSize = gridSize;

        this.allocatePixelBuffer();
        this.adjustCanvasSize();

        // Reset history cause snapshots are grid-size specific.
        // Pretending we can “undo” across different dimensions is how you invent nonsense.
        this.undoStack = [];
        this.redoStack = [];
        this.pushHistory(destructive ? "grid-change" : "grid");

        this.hoverCell = void 0;
        this.lastPaintedKey = void 0;

        this.updateStatus();
        this.render();
      }

      setTool(tool) {
        const { ui } = this
        this.tool = tool;

        ui.drawTool.classList.toggle(
          "active",
          tool === "draw",
        );
        ui.eraseTool.classList.toggle(
          "active",
          tool === "erase",
        );
        ui.fillTool.classList.toggle(
          "active",
          tool === "fill",
        );
        ui.pickTool.classList.toggle(
          "active",
          tool === "pick",
        );

        this.updateStatus();
        this.render();
      }

      setColor(colorAny, fromPicker = false) {
        let color;
        switch (typeof colorAny) {
          case 'number': color = cast(colorAny); break;
          case 'string': color = colorInt(colorAny); break;
        }
        this.currentColor = color;
        this.currentColorStr = colorStr(color);
        this.ui.colorPicker.value = this.currentColorStr.slice(0, 7);

        if (fromPicker) this.addRecentColor(color);
        this.renderPalette();
      }

      addRecentColor(color) {
        const c = color;
        this.recentColors = this.recentColors.filter(
          (i) => i !== c,
        );
        this.recentColors.unshift(c);
        if (this.recentColors.length > this.maxRecent)
          this.recentColors.pop();
      }

      loadSavedSlots() {
        try {
          const raw = localStorage.getItem(
            "tabarc_pixelstudio_savedSlots",
          );
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) {
            this.savedSlots = Array.from(
              { length: 8 },
              (_, i) => parsed[i] ?? 0,
            );
          }
        } catch (e) {
          console.error('loadSavedSlots', e)
        }
      }

      saveSavedSlots() {
        try {
          localStorage.setItem(
            "tabarc_pixelstudio_savedSlots",
            JSON.stringify(this.savedSlots),
          );
        } catch (e) {
          console.error('saveSavedSlots', e)
        }
      }

      renderPalette() {
        const { ui } = this
        ui.recentSwatches.innerHTML = "";
        for (const c of this.recentColors) {
          ui.recentSwatches.appendChild(
            this.makeSwatch(c, {
              selected:
                c === this.currentColor,
              onClick: () => this.setColor(c, false),
              title: c,
            }),
          );
        }

        ui.savedSwatches.innerHTML = "";
        for (let i = 0, len = this.savedSlots.length; i < len; ++i) {
          const c = this.savedSlots[i];
          const el = this.makeSwatch(c, {
            selected:
              c &&
              c.toLowerCase() ===
              this.currentColor,
            title: c
              ? `Slot ${i + 1}: ${c} (Shift+Click to overwrite)`
              : `Slot ${i + 1}: empty (Shift+Click to save)`,
            onClick: (evt) => {
              if (evt.shiftKey) {
                this.savedSlots[i] =
                  this.currentColor;
                this.saveSavedSlots();
                this.renderPalette();
                return;
              }
              if (c) this.setColor(c, false);
            },
          });
          ui.savedSwatches.appendChild(el);
        }
      }

      makeSwatch(color, { selected, onClick, title }) {
        const btn = h("button");
        btn.className =
          "swatch" +
          (selected ? " swatch--selected" : "") +
          (!color ? " swatch--empty" : "");
        btn.title = title || "";
        btn.setAttribute("aria-label", title || "Color swatch");
        if (color) btn.style.background = colorStr(color);
        btn.addEventListener("click", (e) => onClick(e));
        return btn;
      }

      openModal() {
        const { ui } = this
        ui.modalGridSize.value = String(this.gridSize);
        ui.modalOverlay.showModal();
        ui.modalConfirm.focus();
      }

      closeModal() {
        this.ui.modalOverlay.close();
      }

      confirmNewProject() {
        const gridSize = parseInt(this.ui.modalGridSize.value, 10);

        this.closeModal();

        if (gridSize !== this.gridSize) {
          this.setGridSize(gridSize, true);
          // setGridSize already resets history and renders
          return;
        }

        // Same grid size: clear and reset history cleanly
        this.clearPixels();

        this.undoStack = [];
        this.redoStack = [];
        this.pushHistory("new-project");

        this.hoverCell = void 0;
        this.lastPaintedKey = void 0;

        this.updateStatus();
        this.render();
      }

      onPointerDown(e) {
        e.preventDefault();
        const {tool} = this
        this.isPointerDown = true;
        this.lastPaintedKey = void 0;
        this.canvas.setPointerCapture?.(e.pointerId);

        const cell = this.getCellFromEvent(e);
        if (cell === void 0) return;

        this.hoverCell = cell;

        if (tool === "pick") {
          this.pickColorAt(cell);
          this.render();
          return;
        }

        if (tool === "fill") {
          const {currentColor} = this
          const target = this.pixels[cell];
          if (target === currentColor) return;

          this.floodFillIterative(cell, target, currentColor);
          this.addRecentColor(currentColor);
          this.renderPalette();
          this.render();
          return;
        }

        if((tool === "draw") || (tool === "erase")){
          this.applyToolAt(cell);
          this.render();
          this.pushHistory(tool);
        }
      }

      onPointerMove(e) {
        const cell = this.getCellFromEvent(e);

        if (cell === void 0) {
          this.hoverCell = void 0;
          this.updateCellStatus(void 0);
          this.render();
          return;
        }

        this.hoverCell = cell;
        this.updateCellStatus(cell);

        if (!this.isPointerDown) {
          // this.render();
          return;
        }

        if (this.tool === "fill" || this.tool === "pick") {
          // Fill is click-only. Pick is click-only.
          return;
        }

        const key = `${cell},${this.tool},${this.brushSize}`;
        if (this.lastPaintedKey === key) {
          return;
        }
        this.lastPaintedKey = key;

        this.applyToolAt(cell);
        this.render();
      }

      onPointerUp() {
        this.isPointerDown = false;
        this.lastPaintedKey = void 0;
        this.updateHistoryButtons();
      }

      onPointerLeave() {
        this.isPointerDown = false;
        this.hoverCell = void 0;
        this.lastPaintedKey = void 0;
        this.updateCellStatus(void 0);
        this.render();
      }

      getCellFromEvent(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = Math.floor(
          (e.clientX - rect.left) / this.pixelSize,
        );
        const y = Math.floor(
          (e.clientY - rect.top) / this.pixelSize,
        );
        if (
          x < 0 ||
          y < 0 ||
          x >= this.gridSize ||
          y >= this.gridSize
        )
          return void 0;
        const i = this.idx(x, y);
        return i;
      }

      applyToolAt(i) {
        const x0 = this.getX(i)
        const y0 = this.getY(i)
        const { brushSize, pixels, gridSize } = this
        const half = Math.floor(this.brushSize / 2);
        const paintValue =
          this.tool === "erase"
            ? 0
            : this.currentColor;

        for (
          let y = y0 - half, endY = y0 - half + brushSize;
          y < endY;
          ++y
        ) {
          for (
            let x = x0 - half, endX = x0 - half + brushSize;
            x < endX;
            ++x
          ) {
            if (
              x < 0 ||
              y < 0 ||
              x >= gridSize ||
              y >= gridSize
            ) continue;
            this.pixels[this.idx(x, y)] = paintValue;
          }
        }
        if (paintValue) {
          this.addRecentColor(paintValue);
          this.renderPalette();
        }
      }

      pickColorAt(i) {
        const c = this.pixels[i];
        if (!c) return; // transparent pick unhelpful
        this.setColor(c, false);
        // Draw mode after pick color
        this.setTool("draw");
      }

      floodFillIterative(cell, target, color) {
        const { pixels } = this
        const g = this.gridSize
        const stack = [cell];
        while (stack.length) {
          const i = stack.pop()
          const x = this.getX(i)
          const y = this.getY(i)
          const current = pixels[i];
          if ((current !== target) || (cast(current) === color)) continue;
          pixels[i] = color;
          if(x < (g - 1)) stack.push(g * y + x + 1);
          if(x) stack.push(g * y + x - 1);
          if(y < (g - 1)) stack.push(g * (y + 1) + x);
          if(y) stack.push(g * (y - 1) + x);
        }
      }

      clearPixels() {
        this.pixels.fill(0);
      }

      flipHorizontal() {
        // Flip should be undoable, so snapshot first.
        // this.pushHistory("flip-h");
        // for (let i = 0, len = this.pixels.length; y < len; ++y) {
        //   this.pixels[y].reverse();
        // }
        // this.render();
      }

      flipVertical() {
        // this.pushHistory("flip-v");
        // this.pixels.reverse();
        // this.render();
      }

      restoreSnapshot(snap) {
        if (!snap || (snap.gridSize !== this.gridSize)) return;
        this.pixels = snap.pixels
        this.updateHistoryButtons();
        this.render();
      }

      pushHistory(reason = "change") {
        const snap = {
          gridSize: this.gridSize,
          pixels: new Int32Array(this.pixels),
          reason,
        };
        this.undoStack.push(snap);

        if (this.undoStack.length > this.maxHistory) {
          this.undoStack.shift();
        }

        this.redoStack = [];
        this.updateHistoryButtons();
      }

      undo() {
        if (this.undoStack.length < 2) return;

        const current = this.undoStack.pop();
        this.redoStack.push(current);

        const prev = this.undoStack[this.undoStack.length - 1];
        this.restoreSnapshot(prev);
      }

      redo() {
        if (!this.redoStack.length) return;

        const next = this.redoStack.pop();
        this.undoStack.push(next);
        this.restoreSnapshot(next);
      }

      updateHistoryButtons() {
        const { ui } = this
        ui.undoBtn.disabled = this.undoStack.length < 2;
        ui.redoBtn.disabled = this.redoStack.length === 0;

        ui.undoBtn.style.filter = ui.undoBtn.disabled
          ? "grayscale(0.4) opacity(0.75)"
          : "none";
        ui.redoBtn.style.filter = ui.redoBtn.disabled
          ? "grayscale(0.4) opacity(0.75)"
          : "none";
      }
      // Its late, im knackered
      updateStatus() {
        const toolName =
          this.tool === "draw"
            ? "Draw"
            : this.tool === "fill"
              ? "Fill"
              : this.tool === "erase"
                ? "Erase"
                : "Pick";

        this.ui.statusTool.textContent = `${toolName}`;
      }

      updateCellStatus(cell) {
        this.ui.statusCell.textContent = cell === void 0
          ? ``
          : `${(this.getX(cell) + "").padStart(2, "\u00A0")}, ${(this.getY(cell) + "").padStart(2, "\u00A0")}`;
      }

      render() {
        this.ctx.clearRect(
          0,
          0,
          this.canvas.width,
          this.canvas.height,
        );

        const { ctx, pal, pixels } = this;
        const s = this.pixelSize
        for (let i = 0, len = pixels.length; i < len; ++i) {
          const c = pixels[i];
          if (!(c & 0xFF)) continue;
          ctx.fillStyle = pal[c] ??= colorStr(c)
          ctx.fillRect(s * this.getX(i), s * this.getY(i), s, s);
        }

        this.drawHoverPreview();

        if (this.showGrid && this.gridOpacity > 0) {
          this.drawGridLines();
        }
      }

      drawHoverPreview() {
        if (this.hoverCell === void 0) return;
        if (
          this.isPointerDown &&
          (this.tool === "fill" || this.tool === "pick")
        )
          return;

        const x = this.getX(this.hoverCell);
        const y = this.getY(this.hoverCell);

        this.ctx.save();
        this.ctx.globalAlpha = 0.35;

        if (this.tool === "erase") {
          this.ctx.fillStyle = "#2d343673";
        } else if (this.tool === "pick") {
          // Pick tool preview: a subtle outline only. No fill.
          this.ctx.globalAlpha = 0.9;
          this.ctx.lineWidth = 2;
          this.ctx.strokeStyle = "rgba(0,0,0,0.25)";
          const s = this.pixelSize;
          this.ctx.strokeRect(
            s * x + 1,
            s * y + 1,
            s - 2,
            s - 2,
          );
          this.ctx.restore();
          return;
        } else {
          this.ctx.fillStyle = this.currentColorStr;
        }

        const half = Math.floor(this.brushSize / 2);
        const s = this.pixelSize;
        for (
          let y1 = y - half;
          y1 < y - half + this.brushSize;
          ++y1
        ) {
          for (
            let x1 = x - half;
            x1 < x - half + this.brushSize;
            ++x1
          ) {
            if (
              x1 < 0 ||
              y1 < 0 ||
              x1 >= this.gridSize ||
              y1 >= this.gridSize
            ) continue;
            this.ctx.fillRect(s * x1, s * y1, s, s);
          }
        }

        this.ctx.globalAlpha = 0.9;
        this.ctx.lineWidth = 2;
        this.ctx.strokeStyle = "rgba(0,0,0,0.18)";
        this.ctx.strokeRect(
          x * this.pixelSize + 1,
          y * this.pixelSize + 1,
          this.pixelSize - 2,
          this.pixelSize - 2,
        );

        this.ctx.restore();
      }

      drawGridLines() {
        this.ctx.save();
        this.ctx.strokeStyle = colorStr(0xFFFFFF00 + this.gridOpacity);
        this.ctx.lineWidth = 1;

        for (let i = 1, len = this.gridSize; i < len; ++i) {
          const p = i * this.pixelSize;

          this.ctx.beginPath();
          this.ctx.moveTo(p + 0.5, 0);
          this.ctx.lineTo(p + 0.5, this.canvas.height);
          this.ctx.stroke();

          this.ctx.beginPath();
          this.ctx.moveTo(0, p + 0.5);
          this.ctx.lineTo(this.canvas.width, p + 0.5);
          this.ctx.stroke();
        }

        this.ctx.restore();
      }

      exportPNG() {
        const { gridSize, pixels, ui } = this
        const s = parseInt(ui.exportScale.value, 10);

        const out = h("canvas");
        out.width = gridSize * s;
        out.height = gridSize * s;

        const octx = out.getContext("2d");
        octx.imageSmoothingEnabled = false;

        for (let i = 0, len = pixels.length; i < len; ++i) {
          const c = pixels[i];
          if (!c) continue;
          octx.fillStyle = colorStr(c);
          octx.fillRect(this.getX(i) * s, this.getY(i) * s, s, s);
        }

        const link = h("a");
        link.download = `pixel-art-${gridSize}x${gridSize}@${s}x.png`;
        link.href = out.toDataURL("image/png");
        link.click();
      }
    }

    let p = new PixelArtStudio();
  </script>
  <!--
MIT License

Copyright (c) 2026 DailyShip.org
Copyright (c) 2026 TABARC-Code

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->