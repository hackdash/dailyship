<!doctype html>
<html lang="en">
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
        name="description"
        content="Draw, fill, color picker, flip, palette, export PNG"
    />
    <title>Pixel Art Studio Silver</title>
    <!--
MIT License

Copyright (c) 2026 DailyShip.org
Copyright (c) 2026 TABARC-Code

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
    <style>
        :root {
            --accent: hsl(240, 30%, 40%);
            --danger: hsl(0, 40%, 40%);
            --danger-soft-hover: hsl(0, 30%, 40%);
            --danger-soft: hsl(0, 20%, 40%);
            --dark: hsl(0, 0%, 20%);
            --line: rgba(50, 50, 50);
            --primary: hsl(120, 10%, 10%);
            --secondary: hsl(150, 10%, 10%);
            accent-color: var(--accent);
            color-scheme: dark;
        }
        * {
            box-sizing: border-box;
            font-family:
                Roboto,
                system-ui,
                -apple-system,
                "Segoe UI",
                sans-serif;
            font-size: 1em;
            margin: 0;
            padding: 0;
        }
        body {
            align-items: flex-start;
            justify-content: center;
            min-height: 100vh;
            padding: 0;
        }
        button {
            text-align: left;
        }
        p {
            line-height: 1.5;
            padding: 0 0.5em;
        }
        pre {
            white-space-collapse: preserve;
            white-space: pre;
        }
        .border,
        .canvas-wrapper,
        .control-group,
        .custom-select,
        .modal,
        .status-pill,
        .swatch {
            border-color: var(--line);
            border-style: solid;
            border-width: 1px;
        }
        .column {
            display: flex;
            flex-direction: column;
        }
        .grow {
            flex-grow: 1;
        }
        .high {
            margin: 1px 0;
        }
        .mono,
        pre {
            font-family: "Roboto Mono", monospace;
        }
        .row {
            display: flex;
            gap: 0.5em;
        }
        .spacer {
            margin-top: 0.5em;
        }
        .wide {
            width: 100%;
        }
        .wrap {
            flex-wrap: wrap;
        }

        .brandbar__link {
            text-decoration: none;
        }
        .pixel-canvas {
            box-shadow: 0 5px 20px rgba(127, 127, 127, 0.25);
            max-width: 100%;
            touch-action: none;
        }
        .round,
        .control-group,
        .custom-select,
        .modal,
        .status-pill {
            border-radius: 1em;
        }
        .btn-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25em;
            margin-bottom: 0.5em;
        }
        .canvas-wrapper {
            margin: auto;
            max-width: 100%;
            padding: 1em;
        }
        .control-shell {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 0.5em;
        }
        .control-group {
            overflow: hidden;
            padding: 0.5em;
        }

        .control-group__title {
            font-weight: 900;
            margin-bottom: 0.5em;
        }

        .control-label {
            display: flex;
            gap: 0.25em;
        }

        .custom-select {
            background: #202020;
            cursor: pointer;
            padding: 0 0.5em;
        }
        .color-input {
            background: 0;
            border: none;
            cursor: pointer;
            height: 2em;
            padding: 0;
        }
        .status-pill {
            align-items: center;
            border-color: var(--line);
            display: inline-flex;
            line-height: 2;
            padding: 0 0.5em;
        }

        .tool-button,
        .high {
            line-height: 2;
        }
        .tool-button {
            background: var(--primary);
            border-radius: 0.25em;
            border-width: 1px;
            cursor: pointer;
            padding: 0 0.5em;
            transition:
                transform 0.15s ease,
                background 0.15s ease,
                filter 0.15s ease;
            user-select: none;
        }

        .tool-button:hover {
            background: var(--secondary);
        }

        .tool-button.active {
            background: var(--accent);
            border-style: inset;
        }
        .tool-button.danger {
            background: var(--danger);
        }

        .tool-button.danger:hover {
            filter: brightness(0.98);
        }

        .tool-button.danger-soft {
            background: var(--danger-soft);
        }
        .tool-button.danger-soft:hover {
            background: var(--danger-soft-hover);
        }

        .palette-block {
            margin-bottom: 0.5em;
        }

        .palette-label {
            margin-bottom: 0.5em;
        }

        .swatch,
        .swatches {
            height: 2.5em;
        }

        .swatch {
            border-radius: 0.5em;
            box-shadow: 0 1px 0.5em rgba(127, 127, 127, 0.25);
            cursor: pointer;
            position: relative;
            width: 2.5em;
        }

        .swatch:focus {
            outline: 0.25em solid;
            outline-color: var(--accent);
            outline-offset: 2px;
        }

        .swatch--empty {
            background:
                linear-gradient(
                    45deg,
                    rgba(127, 127, 127, 0.1) 25%,
                    transparent 25%
                ),
                linear-gradient(
                    -45deg,
                    rgba(127, 127, 127, 0.1) 25%,
                    transparent 25%
                ),
                linear-gradient(
                    45deg,
                    transparent 75%,
                    rgba(127, 127, 127, 0.1) 75%
                ),
                linear-gradient(
                    -45deg,
                    transparent 75%,
                    rgba(127, 127, 127, 0.1) 75%
                );
            background-position:
                0 0,
                0 5px,
                5px -5px,
                -5px 0px;
            background-size: 0.5em 0.5em;
        }

        .swatch--selected::after {
            border-radius: 0.5em;
            border: 0.25em solid;
            border-color: var(--accent);
            content: "";
            inset: -3px;
            position: absolute;
        }

        .modal-overlay[open] {
            display: grid;
        }
        .modal-overlay {
            background: rgba(0, 0, 0, 0.5);
            border: 0;
            height: 100vh;
            padding: 1.5em;
            place-items: center;
            width: 100vw;
        }
        .modal {
            background: hsl(0, 0%, 30%);
            box-shadow: 0 1.5em 3em rgba(0, 0, 0, 0.5);
            max-width: 30em;
            overflow: hidden;
            width: 100%;
        }

        .modal__head {
            align-items: center;
            display: flex;
            justify-content: space-between;
            padding: 0.75em 1.25em;
        }

        .modal__text {
            padding: 0;
        }
        .modal__title {
            font-weight: 900;
        }

        .modal__body {
            padding: 1em;
        }

        .modal__actions {
            display: flex;
            gap: 0.5em;
            /* justify-content: flex-end; */
            padding: 0.75em 1.25em;
        }
    </style>
    <body class="column">
        <main class="row wrap">
            <section class="control-shell" aria-label="Controls">
                <div class="control-group" aria-label="Canvas settings">
                    <div class="control-group__title row">
                        <span class="high">Canvas</span>
                        <button
                            id="newProjectBtn"
                            class="tool-button danger-soft grow"
                            type="button"
                        >
                            New
                        </button>
                    </div>

                    <label class="control-label high">
                        <span class="high">Size</span>
                        <select id="gridSize" class="custom-select grow" disabled>
                            <option value="16">16</option>
                            <option value="32">32</option>
                            <option value="64">64</option>
                        </select>
                    </label>

                    <div class="row">
                        <label class="tool-button">
                            <input id="toggleGrid" checked type="checkbox" />
                            Grid
                        </label>
                        <label class="control-label grow">
                            <span class="high">Opacity</span>
                            <input
                                class="grow"
                                class="range"
                                id="gridOpacity"
                                max="100"
                                min="0"
                                type="range"
                                value="35"
                            />
                        </label>
                    </div>
                </div>

                <div class="control-group" aria-label="Tools">
                    <!-- <div class="control-group__title">Tools</div> -->
                    <div class="btn-row">
                        <button
                            id="drawTool"
                            class="tool-button active"
                            type="button"
                        >
                            <u>D</u>raw
                        </button>
                        <button
                            id="eraseTool"
                            class="tool-button"
                            type="button"
                        >
                            <u>E</u>rase
                        </button>
                        <button id="fillTool" class="tool-button" type="button">
                            <u>F</u>ill
                        </button>
                        <button id="pickTool" class="tool-button" type="button">
                            P<u>i</u>ck
                        </button>
                    </div>
                    <div class="btn-row">
                        <button
                            id="undoBtn"
                            class="tool-button"
                            type="button"
                            title="Cmd+Z"
                        >
                            Undo
                        </button>
                        <button
                            id="redoBtn"
                            class="tool-button"
                            type="button"
                            title="Cmd+Shift+Z or Cmd+Y"
                        >
                            Redo
                        </button>
                        <button
                            id="clearBtn"
                            class="tool-button danger"
                            type="button"
                        >
                            Clear
                        </button>
                    </div>
                    <div class="btn-row">
                        <div class="control-group__title high">Flip</div>
                        <button id="flipHBtn" class="tool-button" type="button">
                            Horizontal
                        </button>
                        <button id="flipVBtn" class="tool-button" type="button">
                            Vertical
                        </button>
                    </div>
                </div>
                <div class="control-group" aria-label="Export">
                    <div class="control-group__title">
                        <button
                            id="exportPNG"
                            class="tool-button wide danger"
                            type="button"
                            title="Cmd+S"
                        >
                            Export PNG
                        </button>
                    </div>
                    <label class="control-label">
                        <div class="high">Scale</div>
                        <select id="exportScale" class="custom-select grow">
                            <option value="1">1</option>
                            <option value="8">8</option>
                            <option value="16">16</option>
                            <option value="32">32</option>
                        </select>
                    </label>

                    <!-- <label class="control-check">
		<input id="exportTransparent" type="checkbox"/>
		Transparent background
	</label> -->
                </div>
                <div class="control-group" aria-label="Palette">
                    <label class="control-group__title control-label">
                        <span class="high">Color</span>
                        <input
                            type="color"
                            id="colorPicker"
                            value="#000000"
                            class="color-input wide"
                        />
                    </label>

                    <div class="palette-block">
                        <!-- <div class="palette-label">Recent</div> -->
                        <div
                            id="recentSwatches"
                            class="swatches row"
                            aria-label="Recent colors"
                        ></div>
                    </div>

                    <div class="palette-block">
                        <div class="palette-label">Saved</div>
                        <div
                            id="savedSwatches"
                            class="swatches row"
                            aria-label="Saved colors"
                        ></div>
                    </div>
                </div>
                <div class="control-group">
                    <div class="mono row wide wrap" aria-label="Status">
                        <span
                            class="status-pill"
                            id="statusTool"
                            style="width: 3.5em"
                            >Draw</span
                        >
                        <label class="status-pill control-label">
                            <div class="high">Brush</div>
                            <select id="brushSize" class="custom-select">
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                            </select>
                        </label>
                        <pre
                            class="status-pill"
                            id="statusCell"
                            style="width: 5em"
                        ></pre>
                    </div>
                </div>
                <div class="control-group">
                    <p>
                        <a
                            class="brandbar__link row"
                            href="https://github.com/TABARC-Code/pixel-art-studio"
                            target="_blank"
                            rel="noreferrer"
                        >
                            <b>TABARC</b>
                            Pixel Art Studio
                        </a>
                    </p>
                    <p>
                        <a
                            class="brandbar__link row"
                            href="https://dailyship.org/"
                            target="_blank"
                            rel="noreferrer"
                        >
                            <b>DailyShip</b>
                            Silver Edition
                        </a>
                    </p>
                </div>
            </section>

            <section class="canvas-wrapper" aria-label="Canvas">
                <canvas
                    id="pixelCanvas"
                    class="pixel-canvas"
                    aria-label="Pixel drawing canvas"
                ></canvas>
            </section>
        </main>

        <!-- New Project modal -->
        <dialog id="modalOverlay" class="modal-overlay">
            <div
                class="modal"
                role="dialog"
                aria-modal="true"
                aria-labelledby="modalTitle"
            >
                <div class="modal__head">
                    <div class="modal__title" id="modalTitle">New Canvas</div>
                </div>

                <div class="modal__body">
                    <!-- <p class="modal__text">
                        This clears the canvas and resets Undo/Redo.<br />
                        Your palette remains.<br />
                        If you want to keep the work, Cancel, and Export PNG.
                    </p> -->

                    <label class="control-label">
                        <span class="high">Canvas Size</span>
                        <select id="modalGridSize" class="custom-select">
                            <option value="16">16</option>
                            <option value="32">32</option>
                            <option value="64">64</option>
                        </select>
                    </label>
                </div>

                <div class="modal__actions">
                    <button id="modalCancel" class="tool-button" type="button">
                        Cancel
                    </button>
                    <button
                        id="modalConfirm"
                        class="tool-button danger"
                        type="button"
                    >
                        Start New
                    </button>
                </div>
            </div>
        </dialog>

        <script>
            class PixelArtStudio {
                constructor() {
                    this.canvas = document.getElementById("pixelCanvas");
                    this.ctx = this.canvas.getContext("2d", {
                        willReadFrequently: true,
                    });

                    this.gridSize = 16;
                    this.pixelSize = 20;

                    this.currentColour = "#000000";
                    this.tool = "draw"; // draw | fill | erase | pick
                    this.brushSize = 1;

                    this.isPointerDown = false;
                    this.showGrid = true;
                    this.gridOpacity = 0.35;

                    this.hoverCell = null;
                    this.lastPaintedKey = null;

                    this.pixels = [];

                    this.undoStack = [];
                    this.redoStack = [];
                    this.maxHistory = 60;

                    this.recentColours = [];
                    this.maxRecent = 10;
                    this.savedSlots = Array.from({ length: 8 }, () => null);

                    this.ui = {
                        gridSize: document.getElementById("gridSize"),
                        colorPicker: document.getElementById("colorPicker"),
                        brushSize: document.getElementById("brushSize"),

                        drawTool: document.getElementById("drawTool"),
                        fillTool: document.getElementById("fillTool"),
                        eraseTool: document.getElementById("eraseTool"),
                        pickTool: document.getElementById("pickTool"),

                        toggleGrid: document.getElementById("toggleGrid"),
                        gridOpacity: document.getElementById("gridOpacity"),

                        undoBtn: document.getElementById("undoBtn"),
                        redoBtn: document.getElementById("redoBtn"),
                        clearBtn: document.getElementById("clearBtn"),

                        flipHBtn: document.getElementById("flipHBtn"),
                        flipVBtn: document.getElementById("flipVBtn"),

                        exportPNG: document.getElementById("exportPNG"),
                        exportScale: document.getElementById("exportScale"),
                        exportTransparent:
                            document.getElementById("exportTransparent"),

                        recentSwatches:
                            document.getElementById("recentSwatches"),
                        savedSwatches: document.getElementById("savedSwatches"),

                        statusTool: document.getElementById("statusTool"),
                        statusCell: document.getElementById("statusCell"),

                        // Modal
                        newProjectBtn: document.getElementById("newProjectBtn"),
                        modalOverlay: document.getElementById("modalOverlay"),
                        modalCancel: document.getElementById("modalCancel"),
                        modalConfirm: document.getElementById("modalConfirm"),
                        modalGridSize: document.getElementById("modalGridSize"),
                    };

                    this.init();
                    this.bindEvents();
                }

                init() {
                    this.loadSavedSlots();
                    this.allocatePixelBuffer();
                    this.adjustCanvasSize();
                    this.pushHistory("init");
                    this.renderPalette();
                    this.updateStatus();
                    this.render();
                }

                allocatePixelBuffer() {
                    this.pixels = Array.from({ length: this.gridSize }, () =>
                        Array.from({ length: this.gridSize }, () => null),
                    );
                }

                adjustCanvasSize() {
                    const maxCanvasPx = 720;
                    this.pixelSize = Math.max(
                        6,
                        Math.floor(maxCanvasPx / this.gridSize),
                    );
                    this.canvas.width = this.gridSize * this.pixelSize;
                    this.canvas.height = this.gridSize * this.pixelSize;
                    this.ctx.imageSmoothingEnabled = false;
                }

                bindEvents() {
                    this.ui.gridSize.addEventListener("change", (e) => {
                        this.setGridSize(parseInt(e.target.value, 10), true);
                    });

                    this.ui.colorPicker.addEventListener("input", (e) => {
                        this.setColour(e.target.value, true);
                    });

                    this.ui.brushSize.addEventListener("change", (e) => {
                        this.brushSize = parseInt(e.target.value, 10);
                        this.updateStatus();
                    });

                    this.ui.drawTool.addEventListener("click", () =>
                        this.setTool("draw"),
                    );
                    this.ui.fillTool.addEventListener("click", () =>
                        this.setTool("fill"),
                    );
                    this.ui.eraseTool.addEventListener("click", () =>
                        this.setTool("erase"),
                    );
                    this.ui.pickTool.addEventListener("click", () =>
                        this.setTool("pick"),
                    );

                    this.ui.toggleGrid.addEventListener("change", (e) => {
                        this.showGrid = e.target.checked;
                        this.updateStatus();
                        this.render();
                    });

                    this.ui.gridOpacity.addEventListener("input", (e) => {
                        this.gridOpacity = Math.max(
                            0,
                            Math.min(1, parseInt(e.target.value, 10) / 100),
                        );
                        this.render();
                    });

                    this.ui.undoBtn.addEventListener("click", () =>
                        this.undo(),
                    );
                    this.ui.redoBtn.addEventListener("click", () =>
                        this.redo(),
                    );

                    this.ui.clearBtn.addEventListener("click", () => {
                        this.pushHistory("clear");
                        this.clearPixels();
                        this.render();
                    });

                    this.ui.flipHBtn.addEventListener("click", () =>
                        this.flipHorizontal(),
                    );
                    this.ui.flipVBtn.addEventListener("click", () =>
                        this.flipVertical(),
                    );

                    this.ui.exportPNG.addEventListener("click", () =>
                        this.exportPNG(),
                    );

                    // Modal events
                    this.ui.newProjectBtn.addEventListener("click", () =>
                        this.openModal(),
                    );
                    this.ui.modalCancel.addEventListener("click", () =>
                        this.closeModal(),
                    );
                    this.ui.modalOverlay.addEventListener("click", (e) => {
                        if (e.target === this.ui.modalOverlay)
                            this.closeModal();
                    });
                    this.ui.modalConfirm.addEventListener("click", () =>
                        this.confirmNewProject(),
                    );

                    // Pointer events
                    this.canvas.addEventListener("pointerdown", (e) =>
                        this.onPointerDown(e),
                    );
                    this.canvas.addEventListener("pointermove", (e) =>
                        this.onPointerMove(e),
                    );
                    this.canvas.addEventListener("pointerup", () =>
                        this.onPointerUp(),
                    );
                    this.canvas.addEventListener("pointercancel", () =>
                        this.onPointerUp(),
                    );
                    this.canvas.addEventListener("pointerleave", () =>
                        this.onPointerLeave(),
                    );

                    // Keyboard shortcuts
                    window.addEventListener("keydown", (e) =>
                        this.onKeyDown(e),
                    );
                }

                onKeyDown(e) {
                    const tag =
                        e.target && e.target.tagName
                            ? e.target.tagName.toLowerCase()
                            : "";
                    if (
                        tag === "input" ||
                        tag === "select" ||
                        tag === "textarea"
                    )
                        return;

                    // Modal handling first. If a dialog is open, the page isn’t in charge.
                    if (this.ui.modalOverlay.open) {
                        if (e.key === "Escape") {
                            e.preventDefault();
                            this.closeModal();
                        }
                        if (e.key === "Enter") {
                            // Enter to confirm, because muscle memory matters.
                            e.preventDefault();
                            this.confirmNewProject();
                        }
                        return;
                    }

                    const key = e.key.toLowerCase();
                    const mod = e.ctrlKey || e.metaKey;

                    if (mod && key === "z" && !e.shiftKey) {
                        e.preventDefault();
                        this.undo();
                        return;
                    }

                    if (
                        (mod && key === "y") ||
                        (mod && key === "z" && e.shiftKey)
                    ) {
                        e.preventDefault();
                        this.redo();
                        return;
                    }

                    if (mod && key === "s") {
                        e.preventDefault();
                        this.exportPNG();
                        return;
                    }

                    if (key === "d") this.setTool("draw");
                    if (key === "e") this.setTool("erase");
                    if (key === "f") this.setTool("fill");
                    if (key === "i") this.setTool("pick");

                    if (key === "g") {
                        this.ui.toggleGrid.checked =
                            !this.ui.toggleGrid.checked;
                        this.ui.toggleGrid.dispatchEvent(new Event("change"));
                    }

                    // Brush size quick steps
                    if (key === "[") {
                        this.brushSize = Math.max(1, this.brushSize - 1);
                        this.ui.brushSize.value = String(this.brushSize);
                        this.updateStatus();
                    }
                    if (key === "]") {
                        this.brushSize = Math.min(3, this.brushSize + 1);
                        this.ui.brushSize.value = String(this.brushSize);
                        this.updateStatus();
                    }

                    // Flips with Shift+H / Shift+V to avoid clobbering normal letters
                    if (e.shiftKey && key === "h") this.flipHorizontal();
                    if (e.shiftKey && key === "v") this.flipVertical();

                    // New project: N. Risky shortcut, but it triggers a modal, not a detonation.
                    if (key === "n") this.openModal();
                }

                setGridSize(newSize, destructive = true) {
                    this.gridSize = newSize;

                    this.allocatePixelBuffer();
                    this.adjustCanvasSize();

                    // Reset history cause snapshots are grid-size specific.
                    // Pretending we can “undo” across different dimensions is how you invent nonsense.
                    this.undoStack = [];
                    this.redoStack = [];
                    this.pushHistory(destructive ? "grid-change" : "grid");

                    this.hoverCell = null;
                    this.lastPaintedKey = null;

                    this.updateStatus();
                    this.render();
                }

                setTool(tool) {
                    this.tool = tool;

                    this.ui.drawTool.classList.toggle(
                        "active",
                        tool === "draw",
                    );
                    this.ui.eraseTool.classList.toggle(
                        "active",
                        tool === "erase",
                    );
                    this.ui.fillTool.classList.toggle(
                        "active",
                        tool === "fill",
                    );
                    this.ui.pickTool.classList.toggle(
                        "active",
                        tool === "pick",
                    );

                    this.updateStatus();
                    this.render();
                }

                setColour(colour, fromPicker = false) {
                    this.currentColour = colour;
                    this.ui.colorPicker.value = colour;

                    if (fromPicker) this.addRecentColour(colour);
                    this.renderPalette();
                    this.render();
                }

                addRecentColour(colour) {
                    const c = colour.toLowerCase();
                    this.recentColours = this.recentColours.filter(
                        (x) => x !== c,
                    );
                    this.recentColours.unshift(c);
                    if (this.recentColours.length > this.maxRecent)
                        this.recentColours.pop();
                }

                loadSavedSlots() {
                    try {
                        const raw = localStorage.getItem(
                            "tabarc_pixelstudio_savedSlots",
                        );
                        if (!raw) return;
                        const parsed = JSON.parse(raw);
                        if (Array.isArray(parsed)) {
                            this.savedSlots = Array.from(
                                { length: 8 },
                                (_, i) => parsed[i] ?? null,
                            );
                        }
                    } catch {
                        /* storage can be broken, app shouldn’t be */
                    }
                }

                saveSavedSlots() {
                    try {
                        localStorage.setItem(
                            "tabarc_pixelstudio_savedSlots",
                            JSON.stringify(this.savedSlots),
                        );
                    } catch {
                        /* again: not a bank */
                    }
                }

                renderPalette() {
                    this.ui.recentSwatches.innerHTML = "";
                    for (const c of this.recentColours) {
                        this.ui.recentSwatches.appendChild(
                            this.makeSwatch(c, {
                                selected:
                                    c === this.currentColour.toLowerCase(),
                                onClick: () => this.setColour(c, false),
                                title: c,
                            }),
                        );
                    }

                    this.ui.savedSwatches.innerHTML = "";
                    for (let i = 0; i < this.savedSlots.length; i++) {
                        const c = this.savedSlots[i];
                        const el = this.makeSwatch(c, {
                            selected:
                                c &&
                                c.toLowerCase() ===
                                    this.currentColour.toLowerCase(),
                            title: c
                                ? `Slot ${i + 1}: ${c} (Shift+Click to overwrite)`
                                : `Slot ${i + 1}: empty (Shift+Click to save)`,
                            onClick: (evt) => {
                                if (evt.shiftKey) {
                                    this.savedSlots[i] =
                                        this.currentColour.toLowerCase();
                                    this.saveSavedSlots();
                                    this.renderPalette();
                                    return;
                                }
                                if (c) this.setColour(c, false);
                            },
                        });
                        this.ui.savedSwatches.appendChild(el);
                    }
                }

                makeSwatch(colour, { selected, onClick, title }) {
                    const btn = document.createElement("button");
                    btn.type = "button";
                    btn.className =
                        "swatch" +
                        (selected ? " swatch--selected" : "") +
                        (!colour ? " swatch--empty" : "");
                    btn.title = title || "";
                    btn.setAttribute("aria-label", title || "Colour swatch");
                    if (colour) btn.style.background = colour;
                    btn.addEventListener("click", (e) => onClick(e));
                    return btn;
                }

                openModal() {
                    // Sync modal controls with current state
                    this.ui.modalGridSize.value = String(this.gridSize);

                    this.ui.modalOverlay.showModal();

                    // Focus something sensible so keyboard users aren’t abandoned
                    this.ui.modalConfirm.focus();
                }

                closeModal() {
                    this.ui.modalOverlay.close();
                }

                confirmNewProject() {
                    const chosen = parseInt(this.ui.modalGridSize.value, 10);

                    this.closeModal();

                    if (!keep && chosen !== this.gridSize) {
                        this.setGridSize(chosen, true);
                        // setGridSize already resets history and renders
                        return;
                    }

                    // Same grid size: clear and reset history cleanly
                    this.clearPixels();

                    this.undoStack = [];
                    this.redoStack = [];
                    this.pushHistory("new-project");

                    this.hoverCell = null;
                    this.lastPaintedKey = null;

                    this.updateStatus();
                    this.render();
                }

                onPointerDown(e) {
                    e.preventDefault();

                    this.isPointerDown = true;
                    this.lastPaintedKey = null;
                    this.canvas.setPointerCapture?.(e.pointerId);

                    const cell = this.getCellFromEvent(e);
                    if (!cell) return;

                    this.hoverCell = cell;

                    // Pick is not a drawing action, so no,no history checkpoint.
                    if (this.tool === "pick") {
                        this.pickColourAt(cell.x, cell.y);
                        this.render();
                        return;
                    }

                    // Transform/draw actions should be undoable.
                    this.pushHistory("stroke-start");

                    if (this.tool === "fill") {
                        const target = this.pixels[cell.y][cell.x];
                        const replacement = this.currentColour.toLowerCase();
                        if (target === replacement) return;

                        this.floodFillIterative(
                            cell.x,
                            cell.y,
                            target,
                            replacement,
                        );
                        this.addRecentColour(replacement);
                        this.renderPalette();
                        this.render();
                        return;
                    }

                    this.applyToolAt(cell.x, cell.y);
                    this.render();
                }

                onPointerMove(e) {
                    const cell = this.getCellFromEvent(e);

                    if (!cell) {
                        this.hoverCell = null;
                        this.updateCellStatus(null);
                        this.render();
                        return;
                    }

                    this.hoverCell = cell;
                    this.updateCellStatus(cell);

                    if (!this.isPointerDown) {
                        this.render();
                        return;
                    }

                    if (this.tool === "fill" || this.tool === "pick") {
                        // Fill is click-only. Pick is click-only.
                        return;
                    }

                    const key = `${cell.x},${cell.y},${this.tool},${this.brushSize}`;
                    if (this.lastPaintedKey === key) return;
                    this.lastPaintedKey = key;

                    this.applyToolAt(cell.x, cell.y);
                    this.render();
                }

                onPointerUp() {
                    this.isPointerDown = false;
                    this.lastPaintedKey = null;
                    this.updateHistoryButtons();
                }

                onPointerLeave() {
                    this.isPointerDown = false;
                    this.hoverCell = null;
                    this.lastPaintedKey = null;
                    this.updateCellStatus(null);
                    this.render();
                }

                getCellFromEvent(e) {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = Math.floor(
                        (e.clientX - rect.left) / this.pixelSize,
                    );
                    const y = Math.floor(
                        (e.clientY - rect.top) / this.pixelSize,
                    );
                    if (
                        x < 0 ||
                        y < 0 ||
                        x >= this.gridSize ||
                        y >= this.gridSize
                    )
                        return null;
                    return { x, y };
                }

                applyToolAt(x, y) {
                    const half = Math.floor(this.brushSize / 2);
                    const paintValue =
                        this.tool === "erase"
                            ? null
                            : this.currentColour.toLowerCase();

                    for (
                        let yy = y - half;
                        yy < y - half + this.brushSize;
                        yy++
                    ) {
                        for (
                            let xx = x - half;
                            xx < x - half + this.brushSize;
                            xx++
                        ) {
                            if (
                                xx < 0 ||
                                yy < 0 ||
                                xx >= this.gridSize ||
                                yy >= this.gridSize
                            )
                                continue;
                            this.pixels[yy][xx] = paintValue;
                        }
                    }

                    if (paintValue) {
                        this.addRecentColour(paintValue);
                        this.renderPalette();
                    }
                }

                pickColourAt(x, y) {
                    const c = this.pixels[y][x];
                    if (!c) return; // picking “white nothing” is usually unhelpful
                    this.setColour(c, false);

                    // Optional UX: return to Draw after picking, because that’s how most people use it.
                    // If you want it to stay on pick, delete the next line.
                    this.setTool("draw");
                }

                floodFillIterative(
                    startX,
                    startY,
                    targetColour,
                    replacementColour,
                ) {
                    const stack = [{ x: startX, y: startY }];
                    while (stack.length) {
                        const { x, y } = stack.pop();
                        if (
                            x < 0 ||
                            y < 0 ||
                            x >= this.gridSize ||
                            y >= this.gridSize
                        )
                            continue;
                        const current = this.pixels[y][x];
                        if (current !== targetColour) continue;
                        this.pixels[y][x] = replacementColour;

                        stack.push({ x: x - 1, y });
                        stack.push({ x: x + 1, y });
                        stack.push({ x, y: y - 1 });
                        stack.push({ x, y: y + 1 });
                    }
                }

                clearPixels() {
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            this.pixels[y][x] = null;
                        }
                    }
                }

                flipHorizontal() {
                    // Flip should be undoable, so snapshot first.
                    this.pushHistory("flip-h");

                    for (let y = 0; y < this.gridSize; y++) {
                        this.pixels[y].reverse();
                    }

                    this.render();
                }

                flipVertical() {
                    this.pushHistory("flip-v");
                    this.pixels.reverse();
                    this.render();
                }

                snapshot() {
                    const flat = new Array(this.gridSize * this.gridSize);
                    let i = 0;
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            flat[i++] = this.pixels[y][x];
                        }
                    }
                    return { gridSize: this.gridSize, flat };
                }

                restoreSnapshot(snap) {
                    if (!snap || snap.gridSize !== this.gridSize) return;
                    let i = 0;
                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            this.pixels[y][x] = snap.flat[i++];
                        }
                    }
                }

                pushHistory(reason = "change") {
                    const snap = this.snapshot();
                    this.undoStack.push(snap);

                    if (this.undoStack.length > this.maxHistory) {
                        this.undoStack.shift();
                    }

                    this.redoStack = [];
                    this.updateHistoryButtons();
                }

                undo() {
                    if (this.undoStack.length < 2) return;

                    const current = this.undoStack.pop();
                    this.redoStack.push(current);

                    const prev = this.undoStack[this.undoStack.length - 1];
                    this.restoreSnapshot(prev);

                    this.updateHistoryButtons();
                    this.render();
                }

                redo() {
                    if (this.redoStack.length === 0) return;

                    const next = this.redoStack.pop();
                    this.undoStack.push(next);
                    this.restoreSnapshot(next);

                    this.updateHistoryButtons();
                    this.render();
                }

                updateHistoryButtons() {
                    this.ui.undoBtn.disabled = this.undoStack.length < 2;
                    this.ui.redoBtn.disabled = this.redoStack.length === 0;

                    this.ui.undoBtn.style.filter = this.ui.undoBtn.disabled
                        ? "grayscale(0.4) opacity(0.75)"
                        : "none";
                    this.ui.redoBtn.style.filter = this.ui.redoBtn.disabled
                        ? "grayscale(0.4) opacity(0.75)"
                        : "none";
                }
                // Its late, im knackered
                updateStatus() {
                    const toolName =
                        this.tool === "draw"
                            ? "Draw"
                            : this.tool === "fill"
                              ? "Fill"
                              : this.tool === "erase"
                                ? "Erase"
                                : "Pick";

                    this.ui.statusTool.textContent = `${toolName}`;
                }

                updateCellStatus(cell) {
                    this.ui.statusCell.textContent = cell
                        ? `${(cell.x + "").padStart(2, "\u00A0")}, ${(cell.y + "").padStart(2, "\u00A0")}`
                        : ``;
                }

                render() {
                    this.ctx.clearRect(
                        0,
                        0,
                        this.canvas.width,
                        this.canvas.height,
                    );
                    this.ctx.fillStyle = "#ffffff";
                    this.ctx.fillRect(
                        0,
                        0,
                        this.canvas.width,
                        this.canvas.height,
                    );

                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            const c = this.pixels[y][x];
                            if (!c) continue;
                            this.ctx.fillStyle = c;
                            this.ctx.fillRect(
                                x * this.pixelSize,
                                y * this.pixelSize,
                                this.pixelSize,
                                this.pixelSize,
                            );
                        }
                    }

                    this.drawHoverPreview();

                    if (this.showGrid && this.gridOpacity > 0) {
                        this.drawGridLines();
                    }
                }

                drawHoverPreview() {
                    if (!this.hoverCell) return;
                    if (
                        this.isPointerDown &&
                        (this.tool === "fill" || this.tool === "pick")
                    )
                        return;

                    const { x, y } = this.hoverCell;

                    this.ctx.save();
                    this.ctx.globalAlpha = 0.35;

                    if (this.tool === "erase") {
                        this.ctx.fillStyle = "rgba(45, 52, 54, 0.45)";
                    } else if (this.tool === "pick") {
                        // Pick tool preview: a subtle outline only. No fill.
                        this.ctx.globalAlpha = 0.9;
                        this.ctx.lineWidth = 2;
                        this.ctx.strokeStyle = "rgba(0,0,0,0.25)";
                        this.ctx.strokeRect(
                            x * this.pixelSize + 1,
                            y * this.pixelSize + 1,
                            this.pixelSize - 2,
                            this.pixelSize - 2,
                        );
                        this.ctx.restore();
                        return;
                    } else {
                        this.ctx.fillStyle = this.currentColour;
                    }

                    const half = Math.floor(this.brushSize / 2);
                    for (
                        let yy = y - half;
                        yy < y - half + this.brushSize;
                        yy++
                    ) {
                        for (
                            let xx = x - half;
                            xx < x - half + this.brushSize;
                            xx++
                        ) {
                            if (
                                xx < 0 ||
                                yy < 0 ||
                                xx >= this.gridSize ||
                                yy >= this.gridSize
                            )
                                continue;
                            this.ctx.fillRect(
                                xx * this.pixelSize,
                                yy * this.pixelSize,
                                this.pixelSize,
                                this.pixelSize,
                            );
                        }
                    }

                    this.ctx.globalAlpha = 0.9;
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeStyle = "rgba(0,0,0,0.18)";
                    this.ctx.strokeRect(
                        x * this.pixelSize + 1,
                        y * this.pixelSize + 1,
                        this.pixelSize - 2,
                        this.pixelSize - 2,
                    );

                    this.ctx.restore();
                }

                drawGridLines() {
                    this.ctx.save();
                    const alpha = 0.35 * this.gridOpacity;
                    this.ctx.strokeStyle = `rgba(0,0,0,${alpha})`;
                    this.ctx.lineWidth = 1;

                    for (let i = 0; i <= this.gridSize; i++) {
                        const p = i * this.pixelSize;

                        this.ctx.beginPath();
                        this.ctx.moveTo(p + 0.5, 0);
                        this.ctx.lineTo(p + 0.5, this.canvas.height);
                        this.ctx.stroke();

                        this.ctx.beginPath();
                        this.ctx.moveTo(0, p + 0.5);
                        this.ctx.lineTo(this.canvas.width, p + 0.5);
                        this.ctx.stroke();
                    }

                    this.ctx.restore();
                }

                exportPNG() {
                    const scale = parseInt(this.ui.exportScale.value, 10);
                    const transparent = this.ui.exportTransparent.checked;

                    const out = document.createElement("canvas");
                    out.width = this.gridSize * scale;
                    out.height = this.gridSize * scale;

                    const octx = out.getContext("2d");
                    octx.imageSmoothingEnabled = false;

                    if (!transparent) {
                        octx.fillStyle = "#ffffff";
                        octx.fillRect(0, 0, out.width, out.height);
                    }

                    for (let y = 0; y < this.gridSize; y++) {
                        for (let x = 0; x < this.gridSize; x++) {
                            const c = this.pixels[y][x];
                            if (!c) continue;
                            octx.fillStyle = c;
                            octx.fillRect(x * scale, y * scale, scale, scale);
                        }
                    }

                    const link = document.createElement("a");
                    link.download = `pixel-art-${this.gridSize}x${this.gridSize}@${scale}x${transparent ? "-transparent" : ""}.png`;
                    link.href = out.toDataURL("image/png");
                    link.click();
                }
            }

            new PixelArtStudio();
        </script>
    </body>
</html>
