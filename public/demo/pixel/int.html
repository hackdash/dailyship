<!doctype html>
<html lang="en">
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="Draw, fill, color picker, flip, palette, export PNG" />
<title>[Int32] Pixel Art Studio Silver</title>
<style>
  :root {
    --accent: hsl(240, 30%, 40%);
    --danger: hsl(0, 40%, 40%);
    --danger-soft-hover: hsl(0, 30%, 40%);
    --danger-soft: hsl(0, 20%, 40%);
    --dark: hsl(0, 0%, 20%);
    --line: rgba(50, 50, 50);
    --primary: hsl(120, 10%, 10%);
    --secondary: hsl(150, 10%, 10%);
    accent-color: var(--accent);
    color-scheme: dark;
  }

  * {
    box-sizing: border-box;
    font-family:
      Roboto,
      system-ui,
      -apple-system,
      "Segoe UI",
      sans-serif;
    font-size: 1em;
    margin: 0;
    padding: 0;
  }

  body {
    align-items: flex-start;
    justify-content: center;
    min-height: 100vh;
    padding: 0;
  }

  button {
    text-align: left;
  }

  input[type=number] {
    text-align: right;
  }

  p {
    line-height: 1.5;
    padding: 0 0.5em;
  }

  pre {
    font-family: "Roboto Mono", monospace;
    white-space-collapse: preserve;
    white-space: pre;
  }

  .border,
  .canvas-wrapper,
  .control-group,
  .custom-select,
  .modal,
  .status-pill,
  .swatch {
    border-color: var(--line);
    border-style: solid;
    border-width: 1px;
  }

  .column {
    display: flex;
    flex-direction: column;
  }

  .grow {
    flex-grow: 1;
  }

  .high {
    margin: 1px 0;
  }

  .mono,
  .row {
    display: flex;
    gap: 0.5em;
  }

  .spacer {
    margin-top: 0.5em;
  }

  .wide {
    width: 100%;
  }

  .wrap {
    flex-wrap: wrap;
  }

  .brandbar__link {
    text-decoration: none;
  }

  .pixel-canvas {
    box-shadow: 0 5px 20px rgba(127, 127, 127, 0.25);
    max-width: 100%;
    touch-action: none;
  }

  .round,
  .control-group,
  .custom-select,
  .modal,
  .status-pill {
    border-radius: 1em;
  }

  .btn-row {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25em;
    margin-bottom: 0.5em;
  }

  .canvas-wrapper {
    margin: auto;
    max-width: 100%;
    /* padding: 1em; */
  }

  /* .control-shell { */
  /* max-width: 13.5em; */
  /* } */

  .control-group {
    overflow: hidden;
    padding: 0.5em;
  }

  .control-group__title {
    font-weight: 900;
    margin-bottom: 0.5em;
  }

  .control-label {
    display: flex;
    gap: 0.25em;
    white-space: nowrap;
  }

  .custom-select {
    background: #202020;
    cursor: pointer;
    padding: 0 0.5em;
  }

  .color-input {
    background: 0;
    border: none;
    cursor: pointer;
    height: 2em;
    padding: 0;
  }

  .status-pill {
    align-items: center;
    border-color: var(--line);
    display: inline-flex;
    line-height: 2;
    padding: 0 0.5em;
  }

  .tool-button,
  .high {
    line-height: 2;
  }

  .tool-button {
    background: var(--primary);
    border-radius: 0.25em;
    border-width: 1px;
    cursor: pointer;
    padding: 0 0.5em;
    transition:
      transform 0.15s ease,
      background 0.15s ease,
      filter 0.15s ease;
    user-select: none;
  }

  .tool-button:hover {
    background: var(--secondary);
  }

  .tool-button.active {
    background: var(--accent);
    border-style: inset;
  }

  .tool-button.danger {
    background: var(--danger);
  }

  .tool-button.danger:hover {
    filter: brightness(0.98);
  }

  .tool-button.danger-soft {
    background: var(--danger-soft);
  }

  .tool-button.danger-soft:hover {
    background: var(--danger-soft-hover);
  }

  /* .palette-block { */
  /* overflow: hidden; */
  /* } */

  .swatch,
  .swatches {
    display: grid;
    grid-template-columns: repeat(4, min-content);
    grid-template-rows: repeat(2, min-content);
  }

  .swatch {
    border-radius: 0.5em;
    box-shadow: 0 1px 0.5em rgba(127, 127, 127, 0.25);
    cursor: pointer;
    height: 2.5em;
    position: relative;
    width: 2.5em;
  }

  .swatch:focus {
    outline: 0.25em solid;
    outline-color: var(--accent);
    outline-offset: 2px;
  }

  .swatch--empty {
    background:
      linear-gradient(45deg,
        rgba(127, 127, 127, 0.1) 25%,
        transparent 25%),
      linear-gradient(-45deg,
        rgba(127, 127, 127, 0.1) 25%,
        transparent 25%),
      linear-gradient(45deg,
        transparent 75%,
        rgba(127, 127, 127, 0.1) 75%),
      linear-gradient(-45deg,
        transparent 75%,
        rgba(127, 127, 127, 0.1) 75%);
    background-position:
      0 0,
      0 5px,
      5px -5px,
      -5px 0px;
    background-size: 0.5em 0.5em;
  }

  .swatch--selected::after {
    border-radius: 0.5em;
    border: 0.25em solid;
    border-color: var(--accent);
    content: "";
    inset: -3px;
    position: absolute;
  }

  .modal-overlay[open] {
    display: grid;
  }

  .modal-overlay {
    background: rgba(0, 0, 0, 0.5);
    border: 0;
    height: 100vh;
    padding: 1.5em;
    place-items: center;
    width: 100vw;
  }

  .modal {
    background: hsl(0, 0%, 30%);
    box-shadow: 0 1.5em 3em rgba(0, 0, 0, 0.5);
    max-width: 30em;
    overflow: hidden;
    width: 100%;
  }

  .modal__head {
    align-items: center;
    display: flex;
    justify-content: space-between;
    padding: 0.75em 1.25em;
  }

  .modal__text {
    padding: 0;
  }

  .modal__title {
    font-weight: 900;
  }

  .modal__body {
    padding: 1em;
  }

  .modal__actions {
    display: flex;
    gap: 0.5em;
    padding: 0.75em 1.25em;
  }
</style>

<body class="column">
  <main class="row wrap">
    <section class="control-shell column wrap" aria-label="Controls">
      <div class="control-group" aria-label="Canvas settings">
        <div class="control-group__title row">
          <span class="high">Canvas</span>
          <button id="newProjectBtn" class="tool-button danger-soft grow" type="button">
            <u>N</u>ew
          </button>
        </div>

        <label class="control-label high">
          <span class="high">Size</span>
          <input id="gridSize" class="status-pill" disabled autocomplete="off" style="width:5ch;">
        </label>

        <div class="row">
          <label class="control-label high">
            Grid
            <input id="toggleGrid" checked type="checkbox" />
          </label>
          <label class="control-label grow">
            <input class="grow" class="range" id="gridOpacity" max="100" min="0" style="width:0" type="range"
              value="35" />
          </label>
        </div>
      </div>

      <div class="control-group" aria-label="Tools">
        <!-- <div class="control-group__title">Tools</div> -->
        <div class="btn-row">
          <button id="drawTool" class="tool-button active" type="button">
            <u>D</u>raw
          </button>
          <button id="eraseTool" class="tool-button" type="button">
            <u>E</u>rase
          </button>
          <button id="fillTool" class="tool-button" type="button">
            <u>F</u>ill
          </button>
          <button id="pickTool" class="tool-button" type="button">
            P<u>i</u>ck
          </button>
        </div>
        <div class="btn-row">
          <button id="undoBtn" class="tool-button" type="button" title="Cmd+Z">
            Undo
          </button>
          <button id="redoBtn" class="tool-button" type="button" title="Cmd+Shift+Z or Cmd+Y">
            Redo
          </button>
          <button id="clearBtn" class="tool-button danger" type="button">
            Clear
          </button>
        </div>
        <!-- <div class="btn-row"> -->
        <!-- <div class="control-group__title high">Flip</div> -->
        <!-- <button id="flipHBtn" class="tool-button" type="button"> -->
        <!-- <u>H</u>orizontal -->
        <!-- </button> -->
        <!-- <button id="flipVBtn" class="tool-button" type="button"> -->
        <!-- <u>V</u>ertical -->
        <!-- </button> -->
        <!-- </div> -->
      </div>
      <div class="control-group" aria-label="Export">
        <div class="control-group__title">
          <button id="exportPNG" class="tool-button wide danger" type="button" title="Cmd+S">
            Export PNG
          </button>
        </div>
        <label class="control-label">
          <div class="high">Scale</div>
          <select id="exportScale" class="custom-select grow">
            <option value="1">1</option>
            <option value="8">8</option>
            <option value="16">16</option>
            <option value="32">32</option>
          </select>
        </label>

        <label class="control-check" checked hidden>
          <input id="exportTransparent" type="checkbox" />
          Transparent background
        </label>
      </div>
      <div class="control-group" aria-label="Palette">
        <label class="control-group__title control-label">
          <span class="high">Color</span>
          <input autocomplete="off" class="color-input wide" id="colorPicker" type="color" value="#000000" />
        </label>

        <div class="palette-block">
          <div id="recentSwatches" class="swatches" aria-label="Recent colors"></div>
        </div>

        <div class="palette-block">
          <div class="control-label spacer">Saved</div>
          <div aria-label="Saved colors" class="swatches" id="savedSwatches"></div>
        </div>
      </div>
      <div class="control-group">
        <div class="mono row wide wrap" aria-label="Status">
          <span class="status-pill" id="statusTool" style="width: 3.5em">Draw</span>
          <label class="status-pill control-label">
            <div class="high">Brush</div>
            <input id="brushSize" value="1" max="5" min="1" maxlength="1" autocomplete="off" type="number">
          </label>
          <pre class="status-pill" id="statusCell" style="width: 5em">&nbsp;</pre>
        </div>
      </div>
      <div class="control-group">
        <p>
          <a class="brandbar__link row" href="https://github.com/TABARC-Code/pixel-art-studio" target="_blank"
            rel="noreferrer">
            <b>TABARC</b>
            Pixel Art Studio
          </a>
        </p>
        <p>
          <a class="brandbar__link row" href="https://dailyship.org/" target="_blank" rel="noreferrer">
            <b>DailyShip</b>
            Silver Edition
          </a>
        </p>
      </div>
    </section>

    <section class="canvas-wrapper" aria-label="Canvas">
      <canvas id="pixelCanvas" class="pixel-canvas" aria-label="Pixel drawing canvas"></canvas>
    </section>
  </main>

  <!-- New Project modal -->
  <dialog id="modalOverlay" class="modal-overlay">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modal__head">
        <div class="modal__title" id="modalTitle">New Canvas</div>
      </div>

      <div class="modal__body">
        <!-- <p class="modal__text">
                        This clears the canvas and resets Undo/Redo.<br />
                        Your palette remains.<br />
                        If you want to keep the work, Cancel, and Export PNG.
                    </p> -->

        <label class="control-label">
          <span class="high">Canvas Size</span>
          <select id="modalGridSize" class="custom-select">
            <option value="16">16</option>
            <option value="32">32</option>
            <option value="64">64</option>
          </select>
        </label>
      </div>

      <div class="modal__actions">
        <button id="modalCancel" class="tool-button" type="button">
          Cancel
        </button>
        <button id="modalConfirm" class="tool-button danger" type="button">
          Start New
        </button>
      </div>
    </div>
  </dialog>

  <script>
    const eid = document.getElementById.bind(document);
    const h = document.createElement.bind(document);

    const cast = (c) => (c < 0) ? (c + 0x100000000) : c;

    // Transform char code to its hexadecimal value
    const hd = (c) => (c & 0xf) + 9 * (c >> 6);

    function colorInt(s) {
      const r = hd(s.charCodeAt(1)) << 4 | hd(s.charCodeAt(2))
      const g = hd(s.charCodeAt(3)) << 4 | hd(s.charCodeAt(4))
      const b = hd(s.charCodeAt(5)) << 4 | hd(s.charCodeAt(6))
      const a = hd(s.charCodeAt(7)) << 4 | hd(s.charCodeAt(8))
      return (r << 24) | (g << 16) | (b << 8) | (a << 0)
    }

    function colorStr(c) {
      return `#${(cast(c)).toString(16).padStart(8, '0')}`
    }

    class PixelArtStudio {
      constructor() {
        this.canvas = eid("pixelCanvas");
        this.ctx = this.canvas.getContext("2d", {
          willReadFrequently: true,
        });
        this.brushSize = 1;
        this.gridOpacity = 0.35;
        this.gridSize = 16;
        this.hoverCell = void 0;
        this.isPointerDown = false;
        this.lastPaintedKey = void 0;
        this.maxHistory = 60;
        this.maxRecent = 8;
        this.pixels = void 0;
        this.pixelSize = 20;
        this.recentColors = [];
        this.redoStack = [];
        this.savedSlots = Array(8).fill(0);
        this.showGrid = true;
        this.tool = "draw"; // draw | erase | fill | pick
        this.undoStack = [];

        this.ui = Object.fromEntries([
          "brushSize",
          "clearBtn",
          "colorPicker",
          "drawTool",
          "eraseTool",
          "exportPNG",
          "exportScale",
          "exportTransparent",
          "fillTool",
          "flipHBtn",
          "flipVBtn",
          "gridOpacity",
          "gridSize",
          "modalCancel",
          "modalConfirm",
          "modalGridSize",
          "modalOverlay",
          "newProjectBtn",
          "pickTool",
          "recentSwatches",
          "redoBtn",
          "savedSwatches",
          "statusCell",
          "statusTool",
          "toggleGrid",
          "undoBtn",
        ].map(id => [id, eid(id)]))

        this.init();
        this.bindEvents();
      }

      init() {
        this.ui.gridSize.value = this.gridSize;
        this.setColor(0x80000000);
        this.loadSavedSlots();
        this.allocatePixelBuffer();
        this.adjustCanvasSize();
        this.pushHistory("init");
        this.renderPalette();
        this.updateStatus();
        this.render();
      }

      idx(x, y) {
        return this.gridSize * y + x;
      }

      getX(i) {
        return i % this.gridSize;
      }

      getY(i) {
        return Math.floor(i / this.gridSize);
      }

      setPixel(i, color) {
        this.pixels[i] = color;
        console.table({i, color, 'this.pixels[i]':this.pixels[i]})
      }

      allocatePixelBuffer() {
        this.pixels = new Int32Array(this.gridSize * this.gridSize);
      }

      adjustCanvasSize() {
        const maxCanvasPx = 720;
        const g = this.gridSize;
        const s = this.pixelSize = Math.max(
          1,
          Math.floor(maxCanvasPx / this.gridSize),
        );
        this.canvas.height = g * s;
        this.canvas.width = g * s;
        this.ctx.imageSmoothingEnabled = false;
      }

      setBrush(value) {
        this.brushSize = Math.max(1, Math.min(5, parseInt(value)));
        this.ui.brushSize.value = this.brushSize;
      };

      bindEvents() {
        const { ui } = this
        const { brushSize } = ui
        ui.colorPicker.addEventListener("input", (e) => {
          this.setColor(e.target.value, true);
        });

        brushSize.addEventListener("blur", (e) => this.setBrush(e.target.value));
        brushSize.addEventListener("change", (e) => this.setBrush(e.target.value));
        brushSize.addEventListener("focus", (e) => brushSize.select());

        ui.drawTool.addEventListener("click", () =>
          this.setTool("draw"),
        );
        ui.fillTool.addEventListener("click", () =>
          this.setTool("fill"),
        );
        ui.eraseTool.addEventListener("click", () =>
          this.setTool("erase"),
        );
        ui.pickTool.addEventListener("click", () =>
          this.setTool("pick"),
        );

        ui.toggleGrid.addEventListener("change", (e) => {
          this.showGrid = e.target.checked;
          this.updateStatus();
          this.render();
        });

        ui.gridOpacity.addEventListener("input", (e) => {
          this.gridOpacity = Math.max(
            0,
            Math.min(1, parseInt(e.target.value, 10) / 100),
          );
          this.render();
        });

        ui.undoBtn.addEventListener("click", () =>
          this.undo(),
        );
        ui.redoBtn.addEventListener("click", () =>
          this.redo(),
        );

        ui.clearBtn.addEventListener("click", () => {
          this.pushHistory("clear");
          this.clearPixels();
          this.render();
        });

        // ui.flipHBtn.addEventListener("click", () =>
        //   this.flipHorizontal(),
        // );
        // ui.flipVBtn.addEventListener("click", () =>
        //   this.flipVertical(),
        // );

        ui.exportPNG.addEventListener("click", () =>
          this.exportPNG(),
        );

        // Modal events
        ui.newProjectBtn.addEventListener("click", () =>
          this.openModal(),
        );
        ui.modalCancel.addEventListener("click", () =>
          this.closeModal(),
        );
        ui.modalOverlay.addEventListener("click", (e) => {
          if (e.target === ui.modalOverlay)
            this.closeModal();
        });
        ui.modalConfirm.addEventListener("click", () =>
          this.confirmNewProject(),
        );

        // Pointer events
        this.canvas.addEventListener("pointerdown", (e) =>
          this.onPointerDown(e),
        );
        this.canvas.addEventListener("pointermove", (e) =>
          this.onPointerMove(e),
        );
        this.canvas.addEventListener("pointerup", () =>
          this.onPointerUp(),
        );
        this.canvas.addEventListener("pointercancel", () =>
          this.onPointerUp(),
        );
        this.canvas.addEventListener("pointerleave", () =>
          this.onPointerLeave(),
        );

        // Keyboard shortcuts
        window.addEventListener("keydown", (e) =>
          this.onKeyDown(e),
        );
      }

      onKeyDown(e) {
        const tag =
          e.target && e.target.tagName
            ? e.target.tagName.toLowerCase()
            : "";
        if (
          tag === "input" ||
          tag === "select" ||
          tag === "textarea"
        )
          return;

        // Modal: Keys for open dialog, ignoring all else.
        if (this.ui.modalOverlay.open) {
          if (e.key === "Escape") {
            e.preventDefault();
            this.closeModal();
          }
          if (e.key === "Enter") {
            e.preventDefault();
            this.confirmNewProject();
          }
          return;
        }

        const key = e.key.toLowerCase();
        const mod = e.ctrlKey || e.metaKey;

        if (mod && key === "z" && !e.shiftKey) {
          e.preventDefault();
          this.undo();
          return;
        }

        if (
          (mod && key === "y") ||
          (mod && key === "z" && e.shiftKey)
        ) {
          e.preventDefault();
          this.redo();
          return;
        }

        if (mod && key === "s") {
          e.preventDefault();
          this.exportPNG();
          return;
        }

        if (key === "g") {
          this.ui.toggleGrid.checked =
            !this.ui.toggleGrid.checked;
          this.ui.toggleGrid.dispatchEvent(new Event("change"));
        }

        if (key === "[") { this.setBrush(this.brushSize - 1); return; }
        if (key === "]") { this.setBrush(this.brushSize + 1); return; }
        if (key === "d") { this.setTool("draw"); return; }
        if (key === "e") { this.setTool("erase"); return; }
        if (key === "f") { this.setTool("fill"); return; }
        if (key === "h") { this.flipHorizontal(); return; }
        if (key === "i") { this.setTool("pick"); return; }
        if (key === "n") { this.openModal(); return; }
        if (key === "v") { this.flipVertical(); return; }
      }

      setGridSize(gridSize, destructive = true) {
        this.ui.gridSize.value = this.gridSize = gridSize;

        this.allocatePixelBuffer();
        this.adjustCanvasSize();

        // Reset history cause snapshots are grid-size specific.
        // Pretending we can “undo” across different dimensions is how you invent nonsense.
        this.undoStack = [];
        this.redoStack = [];
        this.pushHistory(destructive ? "grid-change" : "grid");

        this.hoverCell = void 0;
        this.lastPaintedKey = void 0;

        this.updateStatus();
        this.render();
      }

      setTool(tool) {
        const { ui } = this
        this.tool = tool;

        ui.drawTool.classList.toggle(
          "active",
          tool === "draw",
        );
        ui.eraseTool.classList.toggle(
          "active",
          tool === "erase",
        );
        ui.fillTool.classList.toggle(
          "active",
          tool === "fill",
        );
        ui.pickTool.classList.toggle(
          "active",
          tool === "pick",
        );

        this.updateStatus();
        this.render();
      }

      setColor(colorAny, fromPicker = false) {
        let color;
        switch (typeof colorAny) {
          case 'number': color = cast(colorAny); break;
          case 'string': color = colorInt(colorAny); break;
        }
        this.currentColor = color;
        this.currentColorStr = colorStr(color);
        this.ui.colorPicker.value = this.currentColorStr;

        if (fromPicker) this.addRecentColor(color);
        this.renderPalette();
      }

      addRecentColor(color) {
        const c = color;
        this.recentColors = this.recentColors.filter(
          (i) => i !== c,
        );
        this.recentColors.unshift(c);
        if (this.recentColors.length > this.maxRecent)
          this.recentColors.pop();
      }

      loadSavedSlots() {
        try {
          const raw = localStorage.getItem(
            "tabarc_pixelstudio_savedSlots",
          );
          if (!raw) return;
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) {
            this.savedSlots = Array.from(
              { length: 8 },
              (_, i) => parsed[i] ?? 0,
            );
          }
        } catch (e) {
          console.error('loadSavedSlots', e)
        }
      }

      saveSavedSlots() {
        try {
          localStorage.setItem(
            "tabarc_pixelstudio_savedSlots",
            JSON.stringify(this.savedSlots),
          );
        } catch (e) {
          console.error('saveSavedSlots', e)
        }
      }

      renderPalette() {
        const { ui } = this
        ui.recentSwatches.innerHTML = "";
        for (const c of this.recentColors) {
          ui.recentSwatches.appendChild(
            this.makeSwatch(c, {
              selected:
                c === this.currentColor,
              onClick: () => this.setColor(c, false),
              title: c,
            }),
          );
        }

        ui.savedSwatches.innerHTML = "";
        for (let i = 0, len = this.savedSlots.length; i < len; ++i) {
          const c = this.savedSlots[i];
          const el = this.makeSwatch(c, {
            selected:
              c &&
              c.toLowerCase() ===
              this.currentColor,
            title: c
              ? `Slot ${i + 1}: ${c} (Shift+Click to overwrite)`
              : `Slot ${i + 1}: empty (Shift+Click to save)`,
            onClick: (evt) => {
              if (evt.shiftKey) {
                this.savedSlots[i] =
                  this.currentColor;
                this.saveSavedSlots();
                this.renderPalette();
                return;
              }
              if (c) this.setColor(c, false);
            },
          });
          ui.savedSwatches.appendChild(el);
        }
      }

      makeSwatch(color, { selected, onClick, title }) {
        const btn = h("button");
        btn.type = "button";
        btn.className =
          "swatch" +
          (selected ? " swatch--selected" : "") +
          (!color ? " swatch--empty" : "");
        btn.title = title || "";
        btn.setAttribute("aria-label", title || "Color swatch");
        if (color) btn.style.background = color;
        btn.addEventListener("click", (e) => onClick(e));
        return btn;
      }

      openModal() {
        const { ui } = this
        ui.modalGridSize.value = String(this.gridSize);
        ui.modalOverlay.showModal();
        ui.modalConfirm.focus();
      }

      closeModal() {
        this.ui.modalOverlay.close();
      }

      confirmNewProject() {
        const gridSize = parseInt(this.ui.modalGridSize.value, 10);

        this.closeModal();

        if (gridSize !== this.gridSize) {
          this.setGridSize(gridSize, true);
          // setGridSize already resets history and renders
          return;
        }

        // Same grid size: clear and reset history cleanly
        this.clearPixels();

        this.undoStack = [];
        this.redoStack = [];
        this.pushHistory("new-project");

        this.hoverCell = void 0;
        this.lastPaintedKey = void 0;

        this.updateStatus();
        this.render();
      }

      onPointerDown(e) {
        e.preventDefault();

        this.isPointerDown = true;
        this.lastPaintedKey = void 0;
        this.canvas.setPointerCapture?.(e.pointerId);

        const cell = this.getCellFromEvent(e);
        if (cell === void 0) return;

        this.hoverCell = cell;

        // Pick is not a drawing action, so no,no history checkpoint.
        if (this.tool === "pick") {
          this.pickColorAt(cell);
          this.render();
          return;
        }

        // Transform/draw actions should be undoable.
        this.pushHistory("stroke-start");

        if (this.tool === "fill") {
          const target = this.pixels[cell];
          const replacement = this.currentColor;
          if (target === replacement) return;

          this.floodFillIterative(
            cell,
            target,
            replacement,
          );
          this.addRecentColor(replacement);
          this.renderPalette();
          this.render();
          return;
        }

        this.applyToolAt(cell);
        this.render();
      }

      onPointerMove(e) {
        const cell = this.getCellFromEvent(e);

        if (cell === void 0) {
          this.hoverCell = void 0;
          this.updateCellStatus(void 0);
          this.render();
          return;
        }

        this.hoverCell = cell;
        this.updateCellStatus(cell);

        if (!this.isPointerDown) {
          this.render();
          return;
        }

        if (this.tool === "fill" || this.tool === "pick") {
          // Fill is click-only. Pick is click-only.
          return;
        }

        const key = `${cell},${this.tool},${this.brushSize}`;
        if (this.lastPaintedKey === key) {
          return;
        }
        this.lastPaintedKey = key;

        this.applyToolAt(cell);
        this.render();
      }

      onPointerUp() {
        this.isPointerDown = false;
        this.lastPaintedKey = void 0;
        this.updateHistoryButtons();
      }

      onPointerLeave() {
        this.isPointerDown = false;
        this.hoverCell = void 0;
        this.lastPaintedKey = void 0;
        this.updateCellStatus(void 0);
        this.render();
      }

      getCellFromEvent(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = Math.floor(
          (e.clientX - rect.left) / this.pixelSize,
        );
        const y = Math.floor(
          (e.clientY - rect.top) / this.pixelSize,
        );
        if (
          x < 0 ||
          y < 0 ||
          x >= this.gridSize ||
          y >= this.gridSize
        )
          return void 0;
        const i = this.idx(x, y);
        return i;
      }

      applyToolAt(i) {
        const x0 = this.getX(i)
        const y0 = this.getY(i)
        const { brushSize, gridSize } = this
        const half = Math.floor(this.brushSize / 2);
        const paintValue =
          this.tool === "erase"
            ? 0
            : this.currentColor;

        for (
          let y = y0 - half, endY = y0 - half + brushSize;
          y < endY;
          ++y
        ) {
          for (
            let x = x0 - half, endX = x0 - half + brushSize;
            x < endX;
            ++x
          ) {
            if (
              x < 0 ||
              y < 0 ||
              x >= gridSize ||
              y >= gridSize
            ) continue;
            this.setPixel(this.idx(x, y), paintValue);
          }
        }
        if (paintValue) {
          this.addRecentColor(paintValue);
          this.renderPalette();
        }
      }

      pickColorAt(i) {
        const c = this.getPixel(i);
        if (!c) return; // picking transparent is usually unhelpful
        this.setColor(c, false);

        // Optional UX: return to Draw after picking, because that’s how most people use it.
        // If you want it to stay on pick, delete the next line.
        this.setTool("draw");
      }

      floodFillIterative(
        startI,
        targetColor,
        replacementColor,
      ) {
        const stack = [startI];
        while (stack.length) {
          const i = stack.pop()
          const x = this.getX(i)
          const y = this.getY(i)
          if (
            x < 0 ||
            y < 0 ||
            x >= this.gridSize ||
            y >= this.gridSize
          ) continue;
          const current = this.pixels[i];
          if (current !== targetColor) continue;
          this.setPixel(i, replacementColor);

          stack.push({ x: x - 1, y });
          stack.push({ x: x + 1, y });
          stack.push({ x, y: y - 1 });
          stack.push({ x, y: y + 1 });
        }
      }

      clearPixels() {
        this.pixels.fill(0);
      }

      flipHorizontal() {
        // Flip should be undoable, so snapshot first.
        // this.pushHistory("flip-h");
        // for (let i = 0, len = this.pixels.length; y < len; ++y) {
        //   this.pixels[y].reverse();
        // }
        // this.render();
      }

      flipVertical() {
        // this.pushHistory("flip-v");
        // this.pixels.reverse();
        // this.render();
      }

      snapshot() {
        return { gridSize: this.gridSize, pixels: this.pixels };
      }

      restoreSnapshot(snap) {
        if (!snap || snap.gridSize !== this.gridSize) return;
        this.pixels = snap.pixels
      }

      pushHistory(reason = "change") {
        const snap = this.snapshot();
        this.undoStack.push(snap);

        if (this.undoStack.length > this.maxHistory) {
          this.undoStack.shift();
        }

        this.redoStack = [];
        this.updateHistoryButtons();
      }

      undo() {
        if (this.undoStack.length < 2) return;

        const current = this.undoStack.pop();
        this.redoStack.push(current);

        const prev = this.undoStack[this.undoStack.length - 1];
        this.restoreSnapshot(prev);

        this.updateHistoryButtons();
        this.render();
      }

      redo() {
        if (this.redoStack.length === 0) return;

        const next = this.redoStack.pop();
        this.undoStack.push(next);
        this.restoreSnapshot(next);

        this.updateHistoryButtons();
        this.render();
      }

      updateHistoryButtons() {
        const { ui } = this
        ui.undoBtn.disabled = this.undoStack.length < 2;
        ui.redoBtn.disabled = this.redoStack.length === 0;

        ui.undoBtn.style.filter = ui.undoBtn.disabled
          ? "grayscale(0.4) opacity(0.75)"
          : "none";
        ui.redoBtn.style.filter = ui.redoBtn.disabled
          ? "grayscale(0.4) opacity(0.75)"
          : "none";
      }
      // Its late, im knackered
      updateStatus() {
        const toolName =
          this.tool === "draw"
            ? "Draw"
            : this.tool === "fill"
              ? "Fill"
              : this.tool === "erase"
                ? "Erase"
                : "Pick";

        this.ui.statusTool.textContent = `${toolName}`;
      }

      updateCellStatus(cell) {
        this.ui.statusCell.textContent = cell === void 0
          ? ``
          : `${(this.getX(cell) + "").padStart(2, "\u00A0")}, ${(this.getY(cell) + "").padStart(2, "\u00A0")}`;
      }

      render() {
        this.ctx.clearRect(
          0,
          0,
          this.canvas.width,
          this.canvas.height,
        );

        const s = this.pixelSize
        const pal = {};
        for (let i = 0, len = this.pixels.length; i < len; ++i) {
          const c = this.pixels[i];
          // if (!c) continue;
          this.ctx.fillStyle = pal[c] ||= colorStr(c)
          this.ctx.fillRect(s * this.getX(i), s * this.getY(i), s, s);
        }

        this.drawHoverPreview();

        if (this.showGrid && this.gridOpacity > 0) {
          this.drawGridLines();
        }
      }

      drawHoverPreview() {
        if (this.hoverCell === void 0) return;
        if (
          this.isPointerDown &&
          (this.tool === "fill" || this.tool === "pick")
        )
          return;

        const x = this.getX(this.hoverCell);
        const y = this.getY(this.hoverCell);

        this.ctx.save();
        this.ctx.globalAlpha = 0.35;

        if (this.tool === "erase") {
          this.ctx.fillStyle = "#2d343673";
        } else if (this.tool === "pick") {
          // Pick tool preview: a subtle outline only. No fill.
          this.ctx.globalAlpha = 0.9;
          this.ctx.lineWidth = 2;
          this.ctx.strokeStyle = "rgba(0,0,0,0.25)";
          const s = this.pixelSize;
          this.ctx.strokeRect(
            s * x + 1,
            s * y + 1,
            s - 2,
            s - 2,
          );
          this.ctx.restore();
          return;
        } else {
          this.ctx.fillStyle = this.currentColorStr;
        }

        const half = Math.floor(this.brushSize / 2);
        const s = this.pixelSize;
        for (
          let y1 = y - half;
          y1 < y - half + this.brushSize;
          ++y1
        ) {
          for (
            let x1 = x - half;
            x1 < x - half + this.brushSize;
            ++x1
          ) {
            if (
              x1 < 0 ||
              y1 < 0 ||
              x1 >= this.gridSize ||
              y1 >= this.gridSize
            ) continue;
            this.ctx.fillRect(s * x1, s * y1, s, s);
          }
        }

        this.ctx.globalAlpha = 0.9;
        this.ctx.lineWidth = 2;
        this.ctx.strokeStyle = "rgba(0,0,0,0.18)";
        this.ctx.strokeRect(
          x * this.pixelSize + 1,
          y * this.pixelSize + 1,
          this.pixelSize - 2,
          this.pixelSize - 2,
        );

        this.ctx.restore();
      }

      drawGridLines() {
        this.ctx.save();
        const alpha = 0.35 * this.gridOpacity;
        this.ctx.strokeStyle = `rgba(0,0,0,${alpha})`;
        this.ctx.lineWidth = 1;

        for (let i = 0, len = this.gridSize; i < len; ++i) {
          const p = i * this.pixelSize;

          this.ctx.beginPath();
          this.ctx.moveTo(p + 0.5, 0);
          this.ctx.lineTo(p + 0.5, this.canvas.height);
          this.ctx.stroke();

          this.ctx.beginPath();
          this.ctx.moveTo(0, p + 0.5);
          this.ctx.lineTo(this.canvas.width, p + 0.5);
          this.ctx.stroke();
        }

        this.ctx.restore();
      }

      exportPNG() {
        const { gridSize, pixels, ui } = this
        const s = parseInt(ui.exportScale.value, 10);
        const transparent = ui.exportTransparent.checked;

        const out = h("canvas");
        out.width = gridSize * s;
        out.height = gridSize * s;

        const octx = out.getContext("2d");
        octx.imageSmoothingEnabled = false;

        if (!transparent) {
          octx.fillStyle = "#ffffff";
          octx.fillRect(0, 0, out.width, out.height);
        }

        for (let i = 0, len = pixels.length; i < len; ++i) {
          const c = this.getPixel(i);
          if (!c) continue;
          octx.fillStyle = colorStr(c);
          octx.fillRect(getX(i) * s, getY(i) * s, s, s);
        }

        const link = h("a");
        link.download = `pixel-art-${gridSize}x${gridSize}@${s}x${transparent ? "-transparent" : ""}.png`;
        link.href = out.toDataURL("image/png");
        link.click();
      }
    }

    let p = new PixelArtStudio();
  </script>
  <!--
MIT License

Copyright (c) 2026 DailyShip.org
Copyright (c) 2026 TABARC-Code

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->